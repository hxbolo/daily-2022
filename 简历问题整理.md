熟悉 HTML5、CSS3、ES6/7/8 等基础前端技能，能够独立完成前端页面的开发和优化

### 内存泄露怎么解决

- 内存泄露是内存没有在正确释放和回收，一个变量不被使用，但是还占据这内存就会导致内存泄漏
- 解决方法
  1. 闭包会导致内存泄露 最后把设置成 null
  2. 定时器会内存泄露， 需要清除定时器
  3. 适当的释放事件处理器 removeEvnetLister 进行移除
  4. 多个对象相互引用时要将不再需要的对象设置为 null

### H5 新增的标签

- header
- footer
- nav
- aside
- mark
- time
- article

### 移动端优化

- 图片进行压缩
- cdn 加速
- 分包
- 减少 http 请求
- 进行响应式设计处理
- 预加载
- 懒加载
- 添加骨架屏
- 使用浏览器缓存
- 减少回流重绘

### 什么是闭包

- 一个函数有权访问另一个函数中的变量的函数
- 特点

  1. 函数嵌套
  2. 内部函数引用外部变量
  3. 变量不会被回收

- 优点: 避免造成全局污染, 成员私有化
- 缺点： 会造成内存泄漏

### 变量提升

- 使用 var 声明的变量和函数会提升到作用域的最顶端
- 变量声明提升： 使用 var 声明会提升到函数作用域或者全局作用域的最顶端，赋值内容还是在原始位置 ，在变量声明之前引用会返回 undefined
- 函数提升： 使用 function 关键字声明的会被提升至作用域的顶端

### 说说你对盒模型理解

- 盒模型分为标准模型和怪异模型
- 标准模型： width: 内容的宽度 ， 盒子宽度： width+ padding + border

- 怪异模型： width： 内容宽度+ padding+border ， 盒子宽度：width

- box-sizing: border-box;(盒子模型)， content-box(标准盒子模型)

### 重绘与回流的区别（哪些操作会引起重绘，哪些操作会引起回流）

- 重绘： 节点不会改变布局，color，visibility，
- 回流： 节点改变， 会导致页面 dom 元素进行更新
- 回流一定重绘， 重绘不一定回流啊

- 减少重绘和回流
  1. css
     - 使用 transform 代替 top
     - 使用 visibility 代替 display:none 前者只会重绘, 后者回流
     - 使用 table 布局 因为只要很小的改变, 就会重新布局
     - 尽可能在 dom 树末端改变 css 回流式不可避免的,但是可以减少
     - 避免设置多次内联样式
  2. js
     - 避免频繁操作样式'
     - 避免频繁操作 dom
     - 避免频繁读取会引起回流/ 重绘的属性 如果需要多次使用, 就用变量存起来
     - 对具有复杂动画的元素使用绝对定位 使他脱机文档流

### 谈谈 BFC，如何触发 BFC

- bfc 块级格式化上下文， 元素垂直方向， 一个个的放

- 触发
  1. float 不为 node
  2. position 为 flexd, absolute
  3. overflow 不为 visible

### 解决高清屏 1px 的问题

- transform： scale (0.5)

### flex: 1 的组成

- flex-grow 放大
- flex-shrink 缩小
- flex-basis 主轴空间

### 说一下原型链

- 每个构造函数都有 prototype 属性， 指向原型
- 每个实例都有个**proto**属性指向原型
- 每个原型对象都有个 construction 指向实例对象
- 对象的**proto** 在当前原型上没有找到对应的属性， 就会一层层的往上找， 直到找到,如果没有找到会返回 null ， 这就是原型链

### 类型判断的方式有哪些

- 类型有： string， number , boolean, undefined ,null ,object, function, Symbol,
- 判断类型
  1. typeof
  2. instance
  3. Object.prototype.toString.call()

### 谈下浅拷贝、深拷贝、继承

- 浅拷贝
  1. object.assign()
  2. arr.concat()
  3. arr.slice()
- 深拷贝
  1. JSON.pase(JSON.stringify)

### 说下 EventLoop（微任务 /宏任务）

- 事件队列：是一个先进先出的
- 主线程： js 运行中的主线程是同步任务
- 宏任务： 代表一个独立的单元， 可以是交互， ajax , settimeout
- 微任务： 是宏任务中的一个部位， 通常是 promise 回调， 或者 nextick

- 执行当前宏任务中的同步代码
- 检查微任务任务队列， 如果有微任务放入微任务队列，直到微任务队列为空
- 从事件队列中取出一个宏任务并执行
- 重复上述步骤， 直到事件队列和微任务队列

### promise

- 解决回调地狱问题
- 有 3 个状态， padding , reslove, reject， 状态一旦改变就不能逆转
- 。then 的回调是一个 promise，如果成功就执行 reslove, 失败就执行 reject
- then 可以被多次调用， 他是一个链式调用， 后面的 then 拿到的回调是上一个的返回值

- all: 传入一个数组， 当这个数组中的每个都 resolve 才会返回成功的值，否则是 reject
- reace: 传入一个数组， 当遇到第一个成功的时候， 直接返回这个成功的值， 直到所有数组执行完， 没有成功才会返回 reject

- finally: 不管成功或者失败最后都会执行 ， 一般用在弹窗关闭上

### ESModule 与与 CommonJs 区别区别

- esmoudle 是输出值的引用， commonjs 是值的拷贝
- esmodule 是编译时执行， commonjs 是运行时编译
- esmodule 可以导出多个值， commonjs 只能是单个值导出
- esmodule 只能写在静态语法顶部，commomjs 可以写在动态语法的判断里
- ES6 Module 的 this 是 undefined，而 CommonJs 的 this 是当前模块；

### package-lock.json 的作用的作用

- 用来锁定依赖包的版本，保持项目版本的一致性

### 谈谈谈谈 V8 垃圾回收机制垃圾回收机制

- 标记清除法
- 引用计数法
- v8

l 熟练掌握 Vue2、3，对框架底层原理有了解

### vue 父子之间的生命周期

- 父 beforeCreate -> 父 created -> 父 beforMount -> 子 beforeCreate -> 子 created -> 子 beforMount ->子 mouted -> 父 mounted

### vue 父子通信

- props
- ref
- $emit
- prove/ inject
- eventBus
- vuex
- $children / $parent

### computed 原理

- computed 依赖数据响应进行数据的缓存和更新
- 通过 get, set 来实现
- 当数据发生改变的时候， 会有一个 dirty 来标记
- 下次访问如果有 dirty 时， 执行对应的 setter 函数，重新计算属性的值并进行缓存

### vue2.0 中如何更新数组数据

- vue 中一些情况页面不会立即响应数据的更新

1. 异步更新 ， 可以使用$nextTick
2. 深层的对象的变化， 需要用到$set 或者 object.assign()
3. 数组的变化： 修改数组或者某个索引使用非响应式的方法会导致视图无法更新，vue 提供了一些变异方法， push, pop,shift, unshift, splice, sort, reverse,可以触发视图的更新，如果**直接修改数组的长度或使用索引直接赋值，可能会导致问题。可以使用 Vue.set 或 splice**：

### $set 原理

**Vue 不能检测到对象的添加或者删除。然而 Vue 在初始化实例时就对属性执行了 setter/getter 转化过程，所以属性必须开始就在对象上，这样才能让 Vue 转化它。**

- 数组更新：

  1. 判断是否数组
  2. 采用数组的变异方法 splice 来修改数组的 value 值
  3. 在通过 defineReactive 进行响应

- 对象更新：
  1. 检测如果对象本身上已有 返回 value 值
  2. 如果对象没有对象本身上， 就赋值然后返回 value 值
  3. 在通过 defineReactive 进行响应

### this.$set 和 vue.set 的区别

连个方法的使用方式都是一样的，都是通过 set 函数导出的，

- vue.set 挂载在 vue 的构造函数上，
- this.$set 挂载在 vue 的原型上

### pinia 和 vuex 的区别

pinia 和 vuex 都是状态管理工具， 都用在 vue 的应用中

- 响应式： vuex 使用在 2.0 中修改状态必须同步的，pinia 是 vue3.0 中，可以支持异步操作，pinia 中只有 state、getter、action，抛弃了 Vuex 中的 Mutation

- 类型安全： vuex 也支持 TypeScript，但在一些情况下，类型推导可能相对较复杂， 没有类型检查， Pinia 在设计上更加友好地支持 TypeScript，提供了更好的类型推导 TypeScript 集成

- 体积上： vuex 相对说体积更加庞大， pinia 体积小巧

### watch 和 watchEffect

- watch 有 3 个值， deep(深层次监听)、 immediate(立即执行)、flush(改变触发时机)默认是 pre 在 dom 更新前调用， post 在 dom 更新后调用

1. watch 只追踪明确定义的数据源， 只有数据源的数据发生变化才会触发回调，watch 能监听到新值和旧值
2. watchEffect 立即执行，在副作用发生期间追踪依赖，自动分析出侦听数据源；
3. watchEffect 无法获取到新值和旧值

### vue2 和 vue3 的 watch 有什么不同

1. vue2 中的 watch 是属于一个模块 ， vue3 中可以多次调用 watch 方法
2. 添加属性上， vue2 中有 deep , immediate vue3 中多了一个 flush
3. vue3 第一个参数可以是不同的数据源， ref, computed, 响应式对象， getter 函数， 也可以是多个数据组成数组
4. 写法上

```js
<!-- vue2 -->
watch:{
  count:(){

  }
}

<!-- vue3 -->
watch(count,()=>{})
watch(()=>user.name,()=>{})
```

### toRef 和 toRefs 区别

- toRef 可以用来为响应式对象某个 prototy 创建一个新的 ref,

  ```js
    const obj = reactive({name:'hx',})

    const name = toRef(obj,name,'name)
  ```

- toRefs 将响应式对象转换成普通对象， 其中每个普通对象都是指向原始对象相应的 ref

- toRefs 可以用在数据的解构赋值操作，解构出来的数据需要用。value 来获取数据

```js
const obj = reactive({ name: 'hx', age: 18 })

const { name, age } = toRefs(obj)
```

### vue3.0 响应式

- ref 和 reactive 的响应式原理都基于 Proxy 对象，通过代理实现对数据的监听和通知。ref 主要用于包装基本类型，而 reactive 适用于对象的深层次响应式。

- ref 通过 geter 和 seert 对 value 数据进行操作，其中 track 函数追踪对 value 的访问，以便在数据变化时通知依赖。

- reactive 在 Proxy 的 getter 和 setter 中，通过 Reflect.get(),Reflect.set()和 track 函数追踪依赖和 trigger 函数触发通知，以便在数据变化时通知依赖。

### diff 算法原理
### vue2和vue3 核心 diff 算法区别？
- Vue 2.x使用的是双向指针遍历的算法，也就是通过**逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合**。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。

- Vue 3.x使用了经过优化的单向遍历算法，也就是只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3还引入了**静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能**。
因此，总体来说，Vue 3相对于Vue 2拥有更高效、更智能的diff算法，能够更好地避免不必要的操作，并提高了渲染性能。

### 讲一下浏览器缓存（协商缓存、强缓存）

- 浏览器缓存分为强缓存和协商缓存
- 强缓存： 缓存数据库中已请求的数据时， 客户端直接从数据库中获取，数据库中没有数据， 才会从服务端获取
  1. catch-control : max-age-t
  2. expries
- 协商缓存： 客户端会缓存一个标示， 如果在这个标识没有失效会返回 304 直接从缓存中获取， 失效了就从服务端获取
  1. Last-Modified
  2. etag

### 输入一个输入一个 url 到页面呈现到浏览器上的全过程到页面呈现到浏览器上的全过程

1. 解析 DNS 获取 ip 地址
2. 建立 tcp 链接进行 3 次握手
3. 客户端想服务端发送请求
4. 服务端响应请求
5. 进行 4 次分手
6. 进行浏览器渲染

### 浏览器渲染过程

1. 将 html 解析成 domtree
2. 将 css 转换成 csstree
3. 合并 domtree 和 csstree 成渲染树
4. 将 rendertree 中的各个节点进行布局， 计算出每个节点的位置
5. 将每个节点进行绘制在页面上

### 渲染阻塞

一般渲染发生阻塞是会在渲染过程中遇到 script 标记会发生阻塞，会等到脚本执行完成之后才会继续构建

- 遵循的是 css 优先， js 之后

### TCP 和和 UDP 的区别的区别

1. tcp 是面向连接的， udp 是无线连接的即发生数据前不需要连接
2. tcp 提供可靠的服务，通过 tcp 连接传送的数据， 不丢失， 不重复，
   udp: 尽可能交付， 不保证可靠交付
3. TCP 是面向字节流，UDP 面向报文
4. tcp 1 对 1 udp 1 对 1 1 对多
5. tcp 首部较大为 20 字节， udp 只有 8 字节

### uniapp 如何可以转回成多端

uniapp 分为编译器和运行时（runtime），是基于 vue.js 开发的框架， 编译器支持条件编译，根据不同平台进行不同的条件编译， 还提供了一些 api 和组件可以根据不同的平台进行自适应适配

<!-- l 熟悉微信、支付宝、淘宝小程序开发
l 熟悉 React 全家桶
l 熟悉 Webpack 前端构建打包工具，配置优化 -->

### webpack 优化

- 多入口情况下，使用 CommonsChunkPlugin 来提取公共代码
- 通过 externals 配置来提取常用库
- 利用 Dllplugin 和 DllReferencePlugin 预编译资源模块， 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来
- 使用 Happypack 实现多线程加速编译
- 使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码
- 拆包
- 使用 HtmlWebpackPlugin 插件来生成 HTML 的模板时候，通过配置属性 minify 进行 html 优化。
1.  压缩代码

- 多进程并行压缩
  - webpack-paralle-uglify-plugin
  - terser-webpack-plugin 开启 parallel 参数

2. 图片压缩
   - 配置 image-webpack-loader
3. 缩小打包作用域
   - exclude/include (确定 loader 规则范围)
4. Tree shaking

   - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的 bundle 中去掉(只能对 ES6 Modlue 生效) 开发中尽可能使用 ES6 Module 的模块，提高 tree shaking 效率

5. Scope hoisting（作用域提升）
   - **构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大**。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突
### 讲一下 plugin 与与 loader 的区别

- loader： 文件加载器 ，加载资源文件， 并进行处理
- plugin: 插件 扩展 webpack 的功能

1. 运行时机上

- loader 在打包之前运行
- plugin 在整个编译周期起作用

2. 配置上

- loader 在 module.roules 中配置
- plugin 在 plugin 中配置每项的 plugin 实例

### webpack 构建流程构建流程

webpack 是一个串行的过程， 从启动到结束会 依次执行以下顺序

- 初始化参数： 从配置文件和 shell 语句中读取和合并参数，得出最终参数
- 开始编译： 用上一步得到的参数 complier 对象，加载所有配置的插件， 执行对象的 run 方法开始执行编译
- 确定入口： 根据配置中的 entry 找出所有入口文件
- 模块化编译： 从入口文件出发， 调用所有配置的 loader 对模块进行编译， 在找出改模块的依赖模块， 再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
- 完成模块编译： 在经过第四步使用 loader 翻译完所有模块后， 得到每个模块被翻译后的最终内容以及他们之间的依赖关系
- 输出资源： 根据入口和模块之间的依赖关系， 组装成一个个包含多个模块的 chunk 再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
- 输出完成： 确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

<!-- l 熟悉前端开发常用的 UI 框架，如 Element、Antd、echarts 等

l 担任前端组长角色把握项目节奏，协调产品研发测试间沟通，任务分配、核心功能开发及 CodeReview。 -->

### 怎么 cr

- 在项目上线前， 和前端同学一起 cr 下当前需求修改的代码， 看有什么不合理的写法或者有更优解， 一起讨论一起进步

### 后台管理系统的结构
- 项目目录结构（src，/src
  /assets         # 存放静态资源，如图片、字体等
  /components     # 公共组件
  /views          # 页面级组件
  /layouts        # 布局组件
  /utils          # 工具函数
  /services       # 数据请求服务
  /store          # 状态管理，使用 Vuex 或其他状态管理库
  /router         # 路由配置
  /styles         # 全局样式
  /locales        # 多语言配置
  /plugins        # 插件配置）
- 页面布局与路由
  用布局组件来组织整体页面结构，如头部、侧边栏、底部等。
  利用路由配置实现页面导航，确保每个页面都有对应的路由
- 权限控制
- 数据请求和状态管理
### 说说你做的后台管理系统

<!-- l 制定项目开发规范和编码规范，推动团队的开发质量和协作能力。 -->

### 开发流程 ， 开发中有什么规范

- eslint+ Prettier+ EditorConfig 来规范
- 解决代码规范问题
- 统一代码风格

<!-- l 工具库和组件库的开发，提高团队的开发效率和代码质量。 -->

### 写过哪些组件

- 公司内部的 axz-ui ui 组件库， 针对开发了定制化的日历组件， 高级搜索， 下拉选择，树形选择器

<!-- l 使用 jsBridge 进行 h5 和 APP 进行通信。 -->

### h5 和 app 怎么进行通信 怎么交互的

1. 原生端提供接口：在原生应用中，开发者通过暴露一些接口（通常是以 JavaScript 对象的形式）来让 Webview 可以调用。这些接口通常以异步方式执行，并通过回调函数将结果传递给 Webview。

2. Webview 注入 JavaScript：在加载 Web 应用的 Webview 中，原生应用会将一个特定的 JavaScript 对象注入到 Webview 的全局环境中，让 Webview 可以访问到原生暴露的接口。

3. Web 应用调用原生接口：在 Web 应用中，通过调用注入的 JavaScript 对象中的方法来触发原生接口的调用。这些方法会将参数传递给原生接口，并等待原生应用的响应。

4. 原生应用执行操作：在原生应用中，收到 Webview 的调用请求后，执行相应的操作。可能涉及到访问原生功能、获取设备信息、打开新窗口、发送网络请求等。

5. 原生应用回调结果：在完成操作后，原生应用通过回调函数将结果传递给 Webview。Webview 中定义的回调函数会被调用，从而让 Web 应用可以得到执行结果。

<!-- l 通过 echarts 绘制数据看板。 -->

### 常用的哪些看板

- 主要就是通过 echars 饼状图， 柱形图， 地铁， 折线图一些常见的看板

## l 参与新技术调研与落地，基于 chatgpt 的提效工具，自搭基于 Stable Diffision 的 AI 图库生成系统。

### 非业务上的贡献

<!-- 快速理解项目需求，预研其中的技术细节，并将其落实到代码层面。

l 开发和迭代微信小程序、支付宝小程序、淘宝小程序等移动应用。 -->

### 小程序和 h5 怎么交互

- 小程序-》 h5~:通过 webview 新建一个页面用来单独存放 web-view 组件，并且所有的内嵌 H5 都可以通过这个页面来实现跳转；
- h5-》 小程序： wx.miniProgram.navigateTo({url:''})

<!-- l 配合神策及听云系统，为公司的⼤数据、运营等团队提供可靠的⽤户数据⽀持。 -->

### 怎么做埋点

<!-- l 使用 vue 全家桶及其配套工具库。 -->

<!-- 项目的基础框架搭建
l 使用 fabric.js+vue+ts 实现图层，模板，图片裁剪等基本功能
l 移动端的预览兼容，适配多机型
l 基础图形的组件封装

使用 vue3+vite+pinia 重构升级 -->

### 重构升级遇到问题 vue2.0 =》 3.0 有什么问题

1. 升级前的准备

- 提前处理一些已兼容的小修改以及被移除的 API（deep 样式穿透/v-for 中的 ref 需要绑定函数/3.0 中移除了 fliter(过滤)方法）

2. 构建工具

- 2.0 使用 webpack 3.0 改成使用 vite,vite 是按需编译的， 无需等待整个项目一起编译

3.

### 怎么进行二次封装， 为什么要进行二次封装

进行二次封装在前端开发中有一些潜在的好处，尤其是在使用第三方组件库时。下面是一些常见的理由：

1. **抽象和封装逻辑：** 通过二次封装，你可以将一些通用的逻辑、样式和配置进行抽象，封装成一个更易用、更符合项目需求的自定义组件。这有助于降低代码重复性，提高代码的可维护性和可读性。

2. **适配项目需求：** 第三方组件库通常是通用的，可能并不完全满足项目的具体需求。通过二次封装，你可以根据项目需求进行定制，添加特定的功能、样式和配置，使组件更符合项目的特定业务逻辑。

3. **简化接口：** 有时候第三方组件库提供的接口可能比较复杂，通过二次封装，你可以简化接口，提供更易用的 API，使组件在项目中更容易被理解和使用。

4. **隐藏实现细节：** 对于一些复杂的组件，可能有很多内部实现细节。通过二次封装，你可以将这些细节隐藏起来，提供一个更高层次的抽象，使组件的使用者无需关心底层实现。

5. **保持一致性：** 在大型项目中，可能会使用多个第三方组件库，为了保持整体 UI 风格的一致性，可以通过二次封装来定制组件的样式，使其与项目的整体设计相匹配。

6. **简化团队协作：** 在团队协作中，通过二次封装，可以提供更清晰的接口和文档，降低其他开发者使用组件的学习成本，提高开发效率。

需要注意的是，在进行二次封装时，需要权衡封装的程度，避免过度封装导致的不必要复杂性。封装应该基于项目实际需求，并考虑到组件的复用性、可维护性以及对未来变化的适应性。

<!-- l 使用虚拟列表高性能渲染万条数据的长列表 -->

### 怎么实现虚拟列表
- 虚拟列表是渲染页面中可列表项，
- 定高： 就是知道屏幕的高度， 每一项的高度， 计算屏幕可渲染出的列表项，然后在进行scroll 滚动计算偏移量， 其中还要记住开始下标和结束下标

- 不定高： 需要预估一个高度，在设置一个缓存比例， 计算上放的可是区域的展示个数，和下方的可是区域的展示个数， 最终获取他的真实的列表数据， 


<!-- l 优化复杂表单、大数据量查询界面，提高首屏加载速度 40%，提升用户操作体验
l 建设公共组件库， 封装树形拖拽、表单生成器、高级搜索等组件按照规范引入组件库 -->

### 说说其中组件库的规范， 大概说下封装流程

- 组件的可复用性：尽量将组件设计成可复用的，避免与具体业务逻辑耦合过深。

- 组件的封装粒度：封装组件时需要考虑组件的封装粒度，尽量保持组件的功能单一，方便维护和复用。

- 组件的 props 和事件：通过 props 向组件传递数据，通过事件向父组件通信，遵循单向数据流的原则。

- 组件的样式隔离：使用 scoped 属性对组件的样式进行隔离，避免样式冲突。

- 组件的命名规范：遵循一定的命名规范，例如使用驼峰式命名或短横线命名。

<!-- l 合同生成将样式，文字转换成字节流生成 PDF -->

### 生成合同怎么实现的

- 将 html 中的文字和样式生成简单的 pdf
- 通过 html2pdf 来实现 ，因为页面简单， 可以直接用这个库字节生成

<!-- 使用 uniapp+uview 搭建页面，编写核心代码，项目目录重构，高复用组件编写 -->

<!-- l 负责与各个资源方对接与协调，项目跟进、交付 -->

### 流程是如何的

- 先进行需求的评审，
- 进行前后端进行进度评审后， 拆分任务，分配任务
- 进行开发， 用例评审
- 提测， bug 修复等
- 上线

<!--
l 项目通过对 H5 打包优化配置打包速度提高 40%，同时优化项目构建体积，提高首屏渲染
时间，解决了布局框架反复重绘，各类特效动画卡顿等优化问题 -->

### 如何优化的

- 压缩代码体积
- 压缩图片
- 移除非必要的依赖包
- 减少 http 请求
- 添加骨架屏
- 进行预加载

<!-- l 对接原⽣团队开发 js2native 用进行 h5 和 APP 进行通信，功能包含：人脸识别、手写签
名、相机相册、拨打电话等，并定义通信规范，落地对接⽂档 -->

### 怎么交互

- postMessage 安全地实现跨源通信
- js 运行提供沙箱环境， 提供渲染引擎用于页面渲染，同事客户端依赖 webview 提供的接口进行实现的

<!-- l 开发 axzi-ui 组件库，主要功能包含：日期选择组器、下拉菜单、模态框，底层弹窗框选
择、树形视图等
l 负责解决移动端兼容性问题 -->

### 遇到了那些兼容问题， 怎么解决的

1. ios 刘海屏兼容： 设置安全距离的上下左右的边距
2. 对于 yyyy-mm-dd，ios 不兼容，ios 只认识 yyyy/mm/dd 格式
3. ios 对 replaceAll 不兼容，使用 replace
4. uniapp 弹窗打开键盘会弹出框过高：uni.onKeyboardHeightChange ()
5. 软键盘弹出导致屏幕被上移
   在 input 中增加:adjust-position="false" 属性
   - 监听软键盘高度，生命周期在 mounted 中 uni.onKeyboardHeightChange
   - 通过软键盘高度进行页面内赋值 uni .createSelectorQuery() .in(this) .select('id');
   - 视情况可以调整距离，popUp 或者编辑区的 transition
6. 取消 ios 在 input 【type= "search"】中自带的搜索图标
`css ::v-deep [type="search"]::-webkit-search-decoration { display: none; } `
<!-- 与后端开发人员沟通数据结构
l 自定义配置 Vue-cli 内嵌的 webpack 配置，如静态资源目录、环境变量等 -->

<!-- l 同产品经理沟通项目边界，明确项目的职责。在限定的上线日期内及不多的人员配置下降
低延期风险。
l 与神策埋点人员、公司大数据开发协调前端埋点 api 规范
l 使用 canvas 绘制生成海报 -->

### 海报是怎么生成的

1. 通过 canvas 生成海报， 通过 canvas 中的 api 绘制其中的图形， 组合成海报需要的样式，其中包括绘制背景图， 图形和文本。在通过 toDateurl 导出成图片

<!-- l 使用 bridge 进行 h5 和宿主（app、小程序）进行通信，达到 h5 调用宿主原生 api 的功
能
l 封装统一跳转，解析 url，根据 url 类型和页面映射，实现统一配置，多种跳转
l 参与团队定期举办交流会议，梳理近期 bug 和线上问题、CodeReview、经典案例分析、
技术分享等，⼀同提⾼团队代码质量的整体⽔平

前端封装响应的组件，渲染数据源，实现专题页面自由配置灵活实现
l 通过组件化专题每个模块的功能， 通过后台进行配置，生成固定模式的数据源
l 与项目经理同步开发进度，分配前端开发任务
l 通过优化图片、按需引入、Webpack 提取公共 js、剔除无用代码等手段，打包文件体积
减 58%; 使用 Webpack 核心特性 splitChunks 合理分包、启用 HTTP2、开启 gzip 等
提升页面加载速度；将首屏时间缩短 56%；
项目

l Antd contributor 之一 -->

### Antd contributor 之一做了什么

1. 新增 bgColor 属性设置二维码背景色

- 原来是通过 style 来设置背景颜色
- 通过设置 `color` 自定义二维码颜色，通过设置 `bgColor` 自定义背景颜色。

2. Popconfirm 阻止 content 事件冒泡
   - 为什么外层组件不能阻止冒泡， 这个组件内部 content 使用的是 Overlay，没法自己加事件阻止事件冒泡
   - 新增 onPopupClick 事件，可用于阻止 content 内部的事件冒泡


### gpt
ChatGPT 帮助我们提升工作效率的第一个方面：给出不熟悉代码含义，帮助程序员更好的理解项目/代码。

ChatGPT 帮助程序员提升工作效率的第二个方面：快速定位 bug，高效解决 bug。

ChatGPT 帮助我们提升效率的第三个方面：优化代码，减少冗余代码的运行时间和过多的内存消耗。

gpt 有些回答的问题也是有错误的， 需要自己鉴别是否对错， gpt 是辅助开发， 不能完全信任



1. 开发中有用cahtgpt做过哪些能提升开发效率的事情
还挺多的，比如有的时候要对数据做格式转换，以前都还要自己慢慢想，用chatgpt直接告诉他我们现在的数据是什么样子 期望转换后的样子，它就能很快的生成好，而且基本都是可以用的，还有写正则，分析ts类型什么的都很方便

2. 那你之前公司有落地基于chatgpt的提效工具吗？或者说你之前用chatgpt做了哪些提效工具？
我们本来一开始是想做一个类似于github的辅助编程代码提示插件的，然后发现太难了，（我们组里高级前端没几个），后来就想先做个简单点的vscode扩展程序，提前内置好一些比如翻译中英文，添加ts类型这种prompt，当然这个prompt也可以用户自己改

3. 怎么优化的
一般基于chatgpt的做优化主要就是靠优化那个prompt，你的promtp（提示词）越精准越详细，它给的答复也就越好，但是如果提示词越长，它的响应速度也会更慢而且更不可控，所以这得权衡利弊，也不是说写越长越好，像一些要求实时性很高的比如说翻译中英文那prompt可以尽量短一些

4.  让你设计一个翻译中英文的promtp你会怎么写
“请把我发给你的内容直接翻译成英文，不需要答复其它任何内容，如果发给你的不是英文，原样答复给我就行“


### sd
5. 你们公司的SD你自己搭的SD吗？
不是的，是我们运维，但是我自己也会搭建，之前根据github上官方仓库down下来，看教程搭起来的，其中需要有科学上网，不然会出很多莫名其妙的问题

6. 这边有什么难点吗?你们这个做了什么
难点应该就是调它那个接口生成图片这些，这个官方文档不是很清楚，得靠自己摸索那些字段哪些是有用的，做了一个icon和贺卡的，用的是c站（网上）的模型，（如果他问什么网站 就说c站，c什么开头的）civitai.
