
自我介绍

你好， 我叫黄馨，很高兴有机会参加这次前端开发面试， 我拥有5年开发前端开发经验，

1. 重构项目 

1. 搭建Statble Diffision  ，调用其api  生成图片
   难点
      1.需要安装python3


 ？？？ 如何启动  sd

   1.  启动stable-diffusion
      cd stable-diffusion-webui
      ./webui.sh --api

   2. 查看可用的API端点。 我们将利用/sdapi/v1/txt2img端点进行文本到图像的转换。

   3. 前端请求接口， 需要有一个loading等待时间，然后在展示页面 


2. 项目中的难点， 如何解决
   cms 
      项目重构，  升级v2->vue3
      1. 注意点
         构建工具：Vite
         状态管理：Pinia

      2. table封装组件，（筛选，树形 ，编辑，选择表头）
         solt / props/ emit

      3. 权限管理
         1. 路由权限( 在路由全局前置钩子中，增加鉴权功能)
               给路由添加一个meta属性对象， 并将need_login设置为true , router.beforeEach钩子
         2. 登录权限(
            1. 在用户登录成功的回调中将后台返回的token直接存储到localStorage，然后同步配置请求默认参数的形式将token取出放入headers中传给后台
         )
         3. 菜单栏权限设置
            前端通过返回的菜单栏列表，去封装一个新的菜单栏数组

            判断 遍历  用户可见的菜单列表 和 所有菜单对比，push成新的菜单

         4. 动态路由设置[管理员能访问管理页面路由，非管理员不能访问该路由]定制化角色权限
            ```js 
            export const routes = [...]; //静态路由

            export const dynamic_routes = [...]; //动态路由

            动态添加，  对比 用户信息冲的权限配置， 进行过滤展示
           
            ```
             vue-router提供的*router.addRouter* ,它能够给已经创建的路由实例继续添加路由信息.
            我们先从vuex里面拿到当前用户的权限列表,然后遍历动态路由数组dynamic_routes,从里面过滤出允许访问的路由,最后将这些路由动态添加到路由实例里.

         5. 按钮权限设置(在路由元信息上定义权限信息，通过自定义指令删除一些DOM节点)
         v- permission
      

   
   安心筑（移动端）
      1. 兼容问题， 
         1. ios软键盘把弹窗往上顶
            解决方案： 
               1. 在 input 中增加:adjust-position="false" 属性
               2. 监听软键盘高度，生命周期在 mounted 中uni.onKeyboardHeightChange
               3. 通过软键盘高度进行页面内赋值uni .createSelectorQuery() .in(this) .select('id');
               4. 视情况可以调整距离，popUp 或者编辑区的 transition
         
         2. 小程序和原生联合调试极为不便，比如小程序启动白屏等
            解决方案： uni 小程序登录失效必须原生提供 API【 logout 】，直接退出到原生登录界面,uni 小程序输出日志需调用原生提供 API【logd loge】，方便原生和小程序联合定位问题。
        
         3. js2native进行h5和APP 通信
            它为JS运行提供了一个沙箱环境，并提供渲染引擎用于页面渲染。
            同时，客户端依赖WebView提供的各种接口，实现对页面请求的拦截和控制。

            postMessage 安全地实现跨源通信

            **这个通信过程主要依赖于WebViewJavascriptBridge 这个桥接库。通过在JavaScript中调用native方法和native调用JavaScript方法，实现APP和H5的互通。**

            **主要通过提供了 callHandler 和 registerHandler 两个方法，分别用于在 JS 中调用 APP 端的方法和注册供 APP 端调用的 JS 方法**

         4. 项目打包优化 （1分钟 => 25s）
            1. 代码拆分
            2. 优化图片（压缩）
            3. 减小依赖包体积（移除不必要的依赖包）
            4. 缩小代码体积
            5. CDN加速(静态资源托管)

            首屏渲染 
               1. 添加骨架屏
               2. 减少http 请求
               3. 预加载关键资源：使用<link rel="preload">标签来预加载关键资源，如字体、CSS和JavaScript文件。
               4. 减少页面体积（减少请求时间）



### 性能优化

1. **响应式设计：** 使用响应式设计原则，确保您的应用能够适应不同尺寸和分辨率的移动设备。使用媒体查询和弹性布局来实现响应式布局。

2. **图像优化：** 图像通常占用大量的带宽和存储空间。使用适当的图像格式（如 WebP），并使用图像压缩工具（如 ImageOptim）来减小图像文件的大小。还可以使用`<picture>`元素和`srcset`属性来提供不同分辨率的图像。

3. **减少 HTTP 请求：** 减少页面加载时的 HTTP 请求次数。合并和压缩 CSS 和 JavaScript 文件，使用 CSS Sprites 合并图像，以减少文件请求次数。

4. **延迟加载：** 仅加载当前屏幕上可见的内容，而不是一次性加载所有内容。这可以通过懒加载技术来实现，特别是对于图片和其他媒体资源。

5. **代码优化：** 精简和优化 JavaScript 和 CSS 代码，以减小文件大小。删除不需要的代码和注释，避免使用过多的第三方库和插件。

6. **使用本地存储：** 使用本地存储（如 LocalStorage 和 SessionStorage）来缓存数据，减少对服务器的请求，提高加载速度。

7. **减少动画和过渡：** 虽然动画和过渡可以增强用户体验，但要谨慎使用，以避免占用过多的 CPU 和内存资源。

8. **优化字体：** 选择合适的字体，并将字体文件进行子集化，以减小字体文件的大小。

9. **使用 CDN：** 使用内容分发网络（CDN）来提供静态资源，以减少加载时间并提高性能。

10. **启用浏览器缓存：** 使用 HTTP 缓存头来启用浏览器缓存，以减少重复加载相同资源。

11. **性能测试：** 使用工具如 Google PageSpeed Insights 或 Lighthouse 进行性能测试，以发现和解决性能问题。

12. **减少重绘和回流：** 避免频繁的 DOM 操作，以减少浏览器的重绘（Repaint）和回流（Reflow）。

13. **网络请求优化：** 使用 HTTP/2 协议来减少网络请求的延迟。还可以使用数据压缩和资源预加载等技术来优化网络请求。

14. **错误处理：** 实现良好的错误处理机制，以处理网络请求失败、异常和其他错误情况，以提供更好的用户体验。

15. **监控和分析：** 使用监控工具和分析工具来监视应用程序的性能，以及用户行为，以及帮助识别和解决问题。

综上所述，移动端优化涉及多个方面，包括资源加载、代码优化、响应性设计和性能测试等。通过采用这些最佳实践，可以提高您的移动应用程序的性能和用户体验。


### 浏览器缓存（强缓存， 协商缓存）
- 强缓存(强缓存 ：当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据) 是利用 http 的返回头中的 Expires 或者Cache-Control 两个字段来控制的，用来表示资源的缓存时间。

   - Expires
   - Cache-Control 是一个相对时间
- 协商缓存 ( 客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回 304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据)
   - Last-Modified
   - Etag


### 内存泄露
内存泄漏是指应用程序中的内存被错误地分配和释放，导致未使用的内存一直被占用，最终可能导致程序性能下降或崩溃

1. **未正确清理事件处理器** 向 DOM 元素添加事件处理器时， 如果不适当地删除这些事件处理器，它们会持有对 DOM 的引用，妨碍垃圾回收器释放相关的内存。
   **解决方法**：在不再需要事件处理器时，务必使用 removeEventListener 来移除它们。

2. **循环引用** 当两个或多个对象相互引用时，即使你不再使用它们，它们也无法被垃圾回收。
   **解决方法**：确保在不再需要对象时，将其引用设置为 null，打破循环引用。

3. **未释放大型数据结构** 处理大型数据集合时，未释放这些数据结构可能导致内存泄漏
   **解决方法**：当你不再需要大型数据结构时，将其设置为 null 以释放内存。

4. **未正确清理定时器和间隔器** 使用 setTimeout 和 setInterval 创建定时器和间隔器时，如果不及时清理它们，它们会持续运行，可能导致内存泄漏。
   **解决方法**：在不再需要定时器或间隔器时，使用 clearTimeout 和 clearInterval 来清理它们。

5. **使用闭包保留对外部作用域的引用** 闭包可以访问其父作用域的变量。如果不小心，闭包可能会保留对外部作用域的引用，导致外部作用域的变量无法被垃圾回收。
   **解决方法**：在不再需要闭包时，确保解除对外部作用域的引用。

### url 输入
1. DNS 解析:将域名解析成 IP 地址
  - 在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。
2. 浏览器建立一条与目标web服务器的TCP链接：TCP 三次握手
  - 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
  - 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
  - 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 断开连接：TCP 四次挥手

### promise  all， reace 

- promise 就是一个类， 在执行这个类的时候， 需要传递一个执行器进去 执行器会立即执行

- promise 有三个不同的状态，  成功 失败 等待  一旦状态改变就无法修改

- then 方法内部做的事情就判断状态， 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败回调函数 then方法是被定义在原型对象中的

- then成功回调有一个参数 表示成功之后的值 then失败回调有一个参数 表示失败后的原因

- 同一个promise对象下面的then方法是可以被调用多次

- then方法是可以被链式调用的, 后面then方法的回调函数拿到值的是上一个then方法的回调函数的返回值

#### all
- promise.all  接收一个数组作为参数， 接收的参数的顺序，是返回结果值的顺序， 返回的是一个promise对象  在all 方法中如果方法都是成功了，返回就是成功的值， 如果有一个失败的值， 那他就是失败的返回

**for循环参与异步方法， 解决方法， 定义一个index 变量， 让index 和arr 的长度相同才执行reslove**


```js
static all(arr) {
    let result = []
    let index = 0
  
    return new MyPromise((reslove, reject) => {
      function addData(key, value) {
        result[key] = value
        index++ 
        if (index === arr.length) {
          reslove(result)
        }
      }
      // for循环参与异步方法， 解决方法， 定义一个index 变量， 让index 和arr 的长度相同才执行reslove
      for (let i = 0; i < arr.length; i++){
        let current = arr[i]
        if (current instanceof MyPromise) {
          // promise对象
          current.then(value =>addData(i,value),reason => reject(reason))
        } else {
          // 普通值
          addData(i,arr[i])
        }
      }
    })
  }
```


### vue


### vue2 vue3 的区别
1.  响应式系统的改进： 2.x 是通过 object.defineProperty()响应， 3.x 通过 proxy 响应，还支持更深的数据响应和数组的数据响应

2. Vue3支持碎片(Fragments)
   Vue2在组件中只有一个根节点。
   Vue3在组件可以拥有多个根节点。

3. 编译优化：对 diff 进行优化
   虚拟 DOM 的优化： vue3.x 中优化了虚拟 DOM 采用了标记和提升所有静态根节点，通过 patch flag 跳过静态节点，更新动态节点，提升 diff 性能

   - Vue2.x 中通过标记静态根节点 优化 diff 的过程
   - Vue3.0 中标记和提升所有静态的根节点，diff 的时候只需要对比动态节点内容
  - Fragments （升级 vetur 插件）
  - 静态提升
  - Patch flag（标记）跳过静态节点，更新动态节点，提升 diff 性能
  - 缓存事件处理函数

4.  Composition API： 3.x 引入 compositionAPI 是基于函数风格的 api，允许用户组合函数来组织和重用代码逻辑。与 options api 相比有更强的代码组织和复用性， 是组建更易于维护

5. 源代码体积的优化，移除不常用的 api

### vue3 的三大模块
三大模块是指 reactivity（响应式模块）、runtime-core（运行时模块）、compiler（编译模块）

### diff 算法

### vue2和vue3 核心 diff 算法区别？
- Vue 2.x使用的是双向指针遍历的算法，也就是通过**逐层比对新旧虚拟DOM树节点的方式来计算出更新需要做的最小操作集合**。但这种算法的缺点是，由于遍历是从左到右、从上到下进行的，当发生节点删除或移动时，会导致其它节点位置的计算出现错误，因此会造成大量无效的重新渲染。

- Vue 3.x使用了经过优化的单向遍历算法，也就是只扫描新虚拟DOM树上的节点，判断是否需要更新，跳过不需要更新的节点，进一步减少了不必要的操作。此外，在虚拟DOM创建后，Vue 3会缓存虚拟DOM节点的描述信息，以便于复用，这也会带来性能上的优势。同时，Vue 3还引入了**静态提升技术，在编译时将一些静态的节点及其子节点预先处理成HTML字符串，大大提升了渲染性能**。
因此，总体来说，Vue 3相对于Vue 2拥有更高效、更智能的diff算法，能够更好地避免不必要的操作，并提高了渲染性能。


### uiapp 为什么可以多端展示

1. uni-app分编译器和运行时（runtime）
编译器支持条件编译，即可以指定某部分代码只编译到特定的终端平台。从而将公用和个性化融合在一个工程中

编译器分vue2版和vue3版
vue2版：基于wepback实现
vue3版：基于Vite实现。性能更快


uni-app runtime包括3部分：基础框架、组件、API



### Webpack 的构建流程是什么(webpack 是一个串行的过程)

1. 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数
2. 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译
3. 确定入口：根据配置中的 entry 找出所有的入口文件
4. 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
5. 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系
6. 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会
7. 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统，在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果


### webpack 优化

1.  压缩代码

- 多进程并行压缩
  - webpack-paralle-uglify-plugin
  - terser-webpack-plugin 开启 parallel 参数

2. 图片压缩
   - 配置 image-webpack-loader
3. 缩小打包作用域
   - exclude/include (确定 loader 规则范围)
4. **Tree shaking**

   - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的 bundle 中去掉(只能对 ES6 Modlue 生效) 开发中尽可能使用 ES6 Module 的模块，提高 tree shaking 效率

5. **Scope hoisting（作用域提升）**
   - **构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大**。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突
6. 代码分割
   webpack 可将代码分割为 chunks 语块运行时在加载
7. **预编译资源模块**:

- 利用 Dllplugin 和 DllReferencePlugin 预编译资源模块， 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来

8.  **实现多线程加速编译**

- 使用 Happypack 实现多线程加速编译 (3.0)
- thread loader (4.0)

9. 分包 通过 externals 配置来提取常用库

- 将 react ,等基础包， 通过 cdn 引入， 不打包进 bundle.js
- 使用 html-webpack-externals-plugin
 


### antd pr
1. 阻止起泡父元素事件  
2. 二维码修改背景颜色

### 可视化大屏， 适配 7
- ：直接根据宽度的比率进行缩放。（宽度比率=网页当前宽 / 设计稿宽）
- scale方案
   1. 利用css的transform属性构造组件以及设计百分比以及scal()方法：
   2. 大屏具体尺寸计算缩放比例，以及设置缩放比例，需要注意的是，绑定resize事件一定别忘了防抖，页面销毁别忘了移除监听事件：


   ```js
   <script>
      export default {
      mounted() {
      // 初始化自适应  ----在刚显示的时候就开始适配一次
      handleScreenAuto();
      // 绑定自适应函数   ---防止浏览器栏变化后不再适配
      window.onresize = () => handleScreenAuto();
      },
      deleted() {
      window.onresize = null;
      },
      methods: {
      // 数据大屏自适应函数
      handleScreenAuto() {
         const designDraftWidth = 1920; //设计稿的宽度
         const designDraftHeight = 960; //设计稿的高度
         // 根据屏幕的变化适配的比例
         const scale =
            document.documentElement.clientWidth /
            document.documentElement.clientHeight <
            designDraftWidth / designDraftHeight
            ? document.documentElement.clientWidth / designDraftWidth
            : document.documentElement.clientHeight / designDraftHeight;
         // 缩放比例
         document.querySelector(
            '#screen',
         ).style.transform = `scale(${scale}) translate(-50%, -50%)`;
      },
      },
      };
      </script>

   ```