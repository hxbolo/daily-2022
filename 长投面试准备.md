岗位职责：

1.  参与 app、 H5、小程序等产品的需求和设计评审，并负责前端功能的开发实现
2.  配合产品迭代，持续扩展功能和优化用户体验
3.  参与前端工程基础设施的开发和维护
4.  完成领导安排的其他事项
    任职要求：
5.  本科及以上学历， 3 年以上 Web 前端开发经验，能独立完成单个模块的前端开
    发工作
6.  熟练掌握 HTML/CSS/Javascript 等前端基础技能，掌握 HTTP 等基本网络协
    议，熟练对接后端 API
7.  熟练掌握 React、 React-router、 redux、 mobx、 rxjs 等前端框架和状态管理
    库
8.  熟练掌握流行 UI 框架如 Ant-design、 Ant-design-mobile 等
9.  熟悉 Webpack 等前端构建技术
10. 熟练掌握 git、 gitlab 等代码管理工具
11. 有责任心，有好的学习能力并乐于创新，和团队保持良好的沟通协作

    ### 说说你对盒模型理解

    - 标准模式 ： width： content , 盒子宽度： content+ padding+ border box-sizing:content-box
    - 怪异模型 : width: content+ padding+ border ,盒子的宽度就是 width box-sizing:border-box

    ### 垂直水平居中实现方案有哪些

    - flex
      display:flex;
      justify-content: center、
      align-items: center
    - 定位
      position: absolute 和 top: 50%、left: 50%
    - margin: auto
    - display: grid 和 place-items: center

    ### 重绘与回流的区别（哪些操作会引起重绘，哪些操作会引起回流）

    - 重绘： 改变样式， 但不改变布局
      - visibility、color、background-colo
    - 回流： 改变样式，元素的大小或者位置发生改变，页面布局改变
      - fontsize,
      - width,height,
      - 激活 css 伪类:hover,脚本操作 DOM,
      - 浏览器的窗口大小发生改变
    - 回流一定重绘， 重绘不一定回流

    ### 谈谈 BFC/FFC/GFC/IFC，如何触发 BFC

    - BFC ： 块级格式化上下文 是一个独立的渲染空间， 有一定的布局规则
      - 内部的 Box 会在**垂直**方向，一个接一个地放置
      - 两个盒子的纵向间距由 margin 属性决定，两个相邻的盒子在垂直方向上的 margin 会有种“重叠合并”的效果，此时纵向间距距离取较大的那个 margin 值
      - 触发 bfc **在元素定位非 static，relative 的情况下触发**
        1. float 不为 none
        2. position 为 flexd 和 absolute
        3. overflow 不为 visible 的元素
    - IFC : 行内格式化上下文中
      - 行内格式化上下文中，boxes 一个接一个地水平排列，起点是包含块的顶部。
        - 水平方向上的 margin border padding 在框之间得到保留
    - FFC ： 自适应格式化上下文
      - display 值为 flex 或者 inline-flex 的元素会自动生成自适应容器。
      - 设置为 flex 的容器会被渲染成一个块级元素，而设置为 inline-flex 的元素会被渲染成一个行内元素，容器外的元素和容器内的子元素不受影响。
    - GFC ： 网格格式化上下文
      - display：gird 产生，与 flex 相似，flex 元素相对于轴线布局，gird 里面可以放多个项目，是一个二维的表格。
      - 产生行和列，每个元素指定在“单元格”，比 flex 更大

    ### 解决高清屏 1px 的问题

    1. 伪元素

    ```css
      setOnePx{
        position: relative;

      }
      .setOnePx::after{
        position: absolute;
        content: "";
        background-color: red;
        display: block;
        width: 100%;
        height: 1px;
        transform: scale(1,0.5);
        top: 50%;
        left: 0;
      }

    <div class="setOnePx"></div>
    ```

    2. 使用边框图片

    ```css
    border: 1px solid transparent;
    border-image: url('./../../image.jpg') 2 repeat;
    ```

    ### 怎么实现一个宽高自适应的正方形

    ```css
    .box {
      width: 50%;
      height: 0;
      padding-bottom: 50%;
      background: red;
    }
    ```

    ### flex: 1 的组成

    - flex: 1 时，它等同于 flex: 1 1 0，表示项目可以在容器中放大但不能缩小，初始尺寸为 0。这样设置可以让项目平均分配剩余空间，使其占据相同的比例空间。

    ```css
      .box{
        flex-grow: // 放大比例
        flex-shrink : 缩小比例
        flex-basis ： 项目占据的主轴空间
      }
    ```

    ### position: fixed 一定是相对于浏览器窗口进行定位吗

    - 正常情况是 是相对于浏览器窗口进行定位的
    - fixed 属性会创建新的层叠上下文。**当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先**。

    ### z-index 属性在什么情况下会失效

    - position 属性设置为 relative、absolute 或 fixed 时，z-index 才会起作用。
    - 元素处于不同的层叠上下文（stacking context）中：当元素所处的层叠上下文不同，z-index 不会直接影响它们之间的堆叠顺序。

    ### 说一下原型链

    1. 每个构造函数都有 prototpye 属性， 指向原型对象
    2. 每个实例上都有**proto**属性， 指向原型对象
    3. 原型对象有一个 construction 指向构造函数
    4. 对象的**proto**的指向， 当自身不存在的属性时，就一层一层的往上找到对象的构造函数， 当 object 时，就没有**proto** 会返回 null

    ### 类型判断的方式有哪些

    - typeof : 用来判断基础类型 null 会返回 object
    - instanceof : s instanceof String
    - Object.prototype.toString.call() : 准确判断出数据类型

    ### 谈下浅拷贝、深拷贝、继承

    1. 浅拷贝

    - Object.assing() Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。

    ```js
    let a = { a: [1], b: 3 }
    var c = Object.assign({}, a)
    ```

    - Array.prototype.concat()

    ```js
    let arr = [1, 2, 4, { a: 1 }]
    let arr1 = arr.concat()
    console.log(arr, arr1)
    ```

    - Array.prototype.slice()

    ```js
    let arr = [
      1,
      3,
      {
        username: ' kobe',
      },
    ]
    let arr3 = arr.slice()
    arr3[2].username = 'wade'
    console.log(arr)
    ```

    2. 深拷贝

    - JSON.parse(JSON.stringify())

    ```js
    let arr = [
      1,
      2,
      3,
      {
        name: 'hx',
      },
    ]
    let arr2 = JSON.parse(JSON.stringify(arr))
    arr2.name = 'bolo'
    console.log(arr, arr2) //[ 1, 2, 3, { name: 'hx' } ] [ 1, 2, 3, { name: 'hx' }, name: 'bolo' ]
    ```

    ```js
    function deepClone(obj) {
      var newObj = obj instanceof Array ? [] : {}
      for (var i in obj) {
        var temple = typeof obj[i] == 'object' ? deepClone(obj[i]) : obj[i]
        newObj[i] = temple
      }
      return newObj
    }
    ```

    ```js
    function deepClone(obj, map = new Map()) {
      // 判读是不是基础类型
      if (typeof obj !== 'Object') {
        return obj
      }

      if (map.get(obj)) {
        return obj
      }
      // 初始化结果
      let result =
        Array.isArray(obj) ||
        Oject.prototype.toString.call(obj) === '[object,Array]'
          ? []
          : {}
      // 防止循环应用
      map.set(obj, result)
      for (let key in obj) {
        // 调用递归
        result[key] = deepClone(obj[key], map)
      }
      return result
    }
    ```

    3. 继承
       它允许一个对象（子类）拥有另一个对象（父类）的属性和方法

    - 构造函数继承：通过在子类构造函数中调用父类构造函数并使用 call() 或 apply() 修改上下文来实现继承；
    - 组合继承： 结合了原型链继承和构造函数继承，既可以继承原型上的方法，又可以继承构造函数中的属性。
    - ES6 中的 class 和 extends 语法糖可以方便地实现继承。

### storage 有跨域限制么

- 在浏览器中有跨域限制
- Web Storage 的数据是与域名相关联的。如果一个页面通过 localStorage 或 sessionStorage 存储了数据，其他页面只能访问同源（同域名、同协议、同端口）下的 Web Storage 数据。不同源的页面无法直接访问或共享 Web Storage 数据。

### 说下 EventLoop（微任务 /宏任务）

- 只想当前宏任务中的同步代码
- 检查微任务队列， 如果存在微任务， 依次执行所有微任务， 直到微任务队列为空
- 从队列事件中取出一个宏任务并执行
- 重复上述步骤， 直到事件队列和微任务对线都为空
- 宏任务和微任务的顺序， 每次执行一个宏任务后， 都会优先执行当前宏任务中的微任务
- 宏任务： settimeout， 、定时器回调、Ajax 请求
- 微任务： promise, nexttick

### new 实现机制

- 创建了一个空对象
- 将新对象的原型链接到构造函数的原型对象
- 执行这个构造函数
- 返回这个对象

```js
function myNew(constructor, ...args) {
  // 1. 创建一个新的空对象
  const obj = {}

  // 2. 将新对象的原型链接到构造函数的原型对象
  obj.__proto__ = constructor.prototype

  // 3. 将构造函数的执行上下文设置为新对象，并执行构造函数
  const result = constructor.apply(obj, args)

  // 4. 如果构造函数没有返回其他对象，则返回这个新对象
  return result instanceof Object ? result : obj
}

function Person(name, age) {
  this.name = name
  this.age = age
}

const person1 = myNew(Person, 'Alice', 30)
console.log(person1) // 输出：Person { name: 'Alice', age: 30 }
```

### null 和 undefined 的区别

- undefined: 表示申明未赋值 或者 一个对象不存在时的默认值

```js
let x // 声明了变量 x，但未赋值，x 的值为 undefined
console.log(x) // 输出 undefined

const obj = {} // 创建一个空对象
console.log(obj.property) // 访问不存在的属性，结果为 undefined
```

- null : 表示一个不存在的值

```js
const y = null // 将变量 y 赋值为 null，表示它没有值
console.log(y) // 输出 null

const obj = null // 将 obj 赋值为 null，表示清空对象
console.log(obj) // 输出 null
```

- 比较值的情况下，undefined 和 null 是相等的

```js
console.log(undefined == null) // 输出 true，它们在比较时相等
console.log(undefined === null) // 输出 false，它们的数据类型不同
```

### 什么是闭包，应用场景有哪些什么是闭包，应用场景有哪些

- 一个函数， 有权访问另一个函数作用域终端变量的函数
- 特点：
  - 函数的嵌套
  - 内部函数引用外部函数的参数和变量
  - 参数和变量不会被垃圾回收机制回收
  - 会造成内存泄露
- 场景

  1. 保护变量状态：通过闭包可以创建私有变量，这些变量对外部是不可见的，从而保护其状态不被外部修改。这在模块化开发中很有用，可以隐藏一些内部实现细节，只暴露必要的接口给外部使用。

  2. 实现封装：闭包可以用来创建对象，其中包含私有变量和公共方法，类似于面向对象编程中的类。

  3. 延长变量的生命周期：当函数返回一个内部函数作为结果时，这个内部函数将保留对其词法环境的引用，使得其外部的变量在函数执行完毕后不会被销毁，从而延长了这些变量的生命周期。

  4. 函数柯里化：通过闭包可以实现函数柯里化（Currying），即将接受多个参数的函数转换为接受一个参数的函数序列。

  5. 定时器和事件监听：函数防抖 使用闭包可以在定时器或事件监听中保留对外部环境的引用，从而在回调函数中使用这些外部变量。

  6. 缓存结果：通过闭包可以缓存一些计算结果，避免重复计算，提高代码性能

### setTimeout 准么为什么

- 会有点误差
- 延迟执行：setTimeout 设置的延迟时间并不是精确的时间点，而是一个最小延迟时间。如果事件循环中有其他代码正在执行，setTimeout 的回调函数可能会被推迟执行。
- 系统负载：当系统负载较重时，事件循环可能会出现延迟。这可能导致 setTimeout 的回调函数执行的时间比预期的要晚。
- 睡眠模式：在某些设备上，当设备进入睡眠模式时，定时器可能会暂停，直到设备被唤醒。这会导致 setTimeout 的回调函数执行时间延迟
  改善
  1. 高精确性的场景： 对于需要精确时间控制的动画或游戏等场景，可以使用 requestAnimationFrame
  2. 对于一些需要精确时间控制的计时器，可以通过记录开始时间，并在每次定时器执行时计算时间差来实现更准确的时间控制

### async await 原理原理

- async await 处理异步的语法糖
- primise 解决 回调地狱的问题，如果线程非常难复杂， promise 会出现。then()大量链式调用，不利于阅读
- async await 通过同步的方式来实现异步

### ESModule 与与 CommonJs 区别区别

- esmoudle 是输出值的引用， commonjs 是值的拷贝
- esmodule 是编译时执行， commonjs 是运行时编译
- esmodule 可以导出多个值， commonjs 只能是单个值导出
- esmodule 只能写在静态语法顶部，commomjs 可以写在动态语法的判断里
- ES6 Module 的 this 是 undefined，而 CommonJs 的 this 是当前模块；

### 内存泄漏与内存溢出区别

内存泄漏（Memory Leak）和内存溢出（Memory Overflow）都是与内存管理相关的问题，但它们有着不同的含义和表现：

- 内存泄漏（Memory Leak）：
  内存泄漏指的是在程序中动态分配的内存没有被正确释放或回收的情况。当一个对象或变量不再被程序使用，但其占用的内存没有被释放，就会导致内存泄漏。这样的内存泄漏会导致可用内存的减少，最终可能导致程序运行变慢、崩溃或占用更多的系统资源。

  内存泄漏通常发生在以下情况：

  - 忘记释放动态分配的内存，导致没有被使用的对象继续存在。
  - 循环引用，导致对象间的相互引用，使得对象无法被垃圾回收。

- 内存溢出（Memory Overflow）：
  内存溢出指的是程序在申请内存时，超出了系统或程序所能提供的内存范围。当程序需要更多内存时，而系统无法分配足够的内存给程序使用，就会导致内存溢出。这种情况下，程序通常会崩溃或产生错误。

  内存溢出通常发生在以下情况：

  - 申请了大量的内存，但系统没有足够的内存可供分配。
  - 递归函数或循环造成堆栈溢出。

### package-lock.json 的作用的作用

- 它的作用是用来锁定项目依赖的版本，确保在不同环境下安装的依赖版本一致，避免因为依赖版本的差异导致项目运行出现问题。
  `package-lock.json` 是 Node.js 项目中的一个重要文件，它的作用是用来锁定项目依赖的版本，确保在不同环境下安装的依赖版本一致，避免因为依赖版本的差异导致项目运行出现问题。

1. 锁定依赖版本：`package-lock.json` 文件会记录当前项目中所有依赖包及其精确的版本号。这样，当你在不同环境中部署项目或共享代码时，可以确保每次安装的依赖版本都是一致的，避免因为依赖版本的差异导致不同环境下的运行结果不同。

2. 提高安装速度：`package-lock.json` 文件会记录依赖包的完整下载地址，包括每个依赖包的依赖项。当你在重新安装依赖时，npm 会直接从锁定的下载地址下载依赖包，而不是再去查询服务器上的最新版本。这样可以大幅度提高依赖包的安装速度。

3. 安全性：`package-lock.json` 文件还包含每个依赖包的安全信息，比如依赖包是否有已知的安全漏洞。这有助于开发者及时发现并解决潜在的安全问题。

总的来说，`package-lock.json` 文件是保证 Node.js 项目依赖版本一致性、提高安装速度和增强项目安全性的重要工具，建议在项目中使用并提交该文件到版本控制系统中，以确保项目在不同环境中的稳定运行。

### [1,2,4].map(parseInt)输出结果输出结果

- [1， nan,nan]
- ['1', '2', '3'].map((v, i, arr) => parseInt(v, i))
- 将一个字符串  string  转换为  radix  进制的整数， radix  为介于 2-36 之间的数。最后都是以十进制形式返回。
- 函数将其第一个参数转换为一个字符串，对该字符串进行解析，然后返回一个整数或  NaN。
- 如果 radix 没有指定或者是 0，则会被指定为 10 进制来解析
- 如果 string 以 0x 0X 开头，则指定为 16 进制来解析。
- 第一个字符不能转换为数字，parseInt  会返回  NaN。

### Promise.resolve(1).then(2).then(Promise.resolve(3)).then(console.log)输出结果输出结果

### for in 和和 for of 区别区别

`for...in` 和 `for...of` 是 JavaScript 中两种不同的循环语法，用于遍历数据结构中的元素，但它们有一些重要的区别：

1. `for...in` 循环：

   - 用于遍历对象的可枚举属性。
   - 循环变量是**对象的键名（属性名）**。
   - 可以遍历对象自身的属性和继承的属性。
   - 遍历的顺序不确定，可能不按照属性的定义顺序。
   - 遍历的属性包括原型链上的所有可枚举属性。
   - 不建议用于遍历数组，因为遍历数组时会遍历出数组的索引，而且可能不按照数组元素的顺序。

示例代码：

```javascript
const obj = { a: 1, b: 2, c: 3 }

for (const key in obj) {
  console.log(key) // 输出 a, b, c
}
```

2. `for...of` 循环：

   - 用于遍历可迭代对象的元素，包括数组、字符串、Set、Map 等。
   - 循环变量是**对象的值，而不是键名**。
   - 只能遍历可迭代对象自身的元素，不能遍历对象的属性。
   - 遍历的顺序按照元素在对象中的顺序进行。
   - 不可遍历普通对象，需要使用 `Object.values()` 或 `Object.entries()` 方法将对象转为可迭代对象后进行遍历。

示例代码：

```javascript
const arr = [1, 2, 3]

for (const element of arr) {
  console.log(element) // 输出 1, 2, 3
}
```

综上所述，`for...in` 适用于遍历对象的属性，包括继承的属性，而 `for...of` 适用于遍历可迭代对象的元素，包括数组等。在遍历数组时，推荐使用 `for...of`，而遍历对象时，如果需要遍历对象的属性，可以使用 `for...in`，但需要注意遍历的顺序可能不固定。对于普通对象，可以使用 `Object.values()` 或 `Object.entries()` 方法后再使用 `for...of` 进行遍历。

### 谈谈谈谈 V8 垃圾回收机制垃圾回收机制

- v8 辣鸡回收采用的是分代回收思想， 内存分为新生代和老生代，
- V8 内存空间一分为二， 小的用于存储新生代对象，新生代存活时间较短， 新生代采用的是复制算法和标记整理
- 大的用于老生代， 采用的是标记清除，标记整理，增量标记算法

4.  新生代对象回收实现

- 回收过程采用**复制算法 + 标记整理**
- 新生代内存区分为两个等大小的空间
- 使用空间为 from ，空闲空间为 to
- 活动对象存储于 from 空间
- 标记整理后将活动对象拷贝至 to
- from 与 to 交换空间完成示范

5.  老生代对象回收实现

- 采用**标记清除， 标记整理， 增量标记算法**
- 首先使用标记清除完成垃圾回收空间的回收
- 采用标记整理进行空间优化
- 采用增量标记进行效率优化

6. 新生代和老生代对比

- 新生代区域回收垃圾使用空间换时间
- 老生代区域垃圾不适合复制算法

### interface 与与 type 区别区别

- 在 TypeScript 中，`interface` 和 `type` 都用于定义自定义类型，但它们有一些区别。

1. `interface`：
   - 主要用于定义对象类型、类类型、函数类型等结构化类型。
   - 可以被继承，通过 `extends` 关键字可以扩展其他接口。
   - 可以被实现，类可以实现接口，确保类具有接口中定义的属性和方法。
   - 可以合并，如果定义了多个同名的接口，会自动合并成一个接口。

示例代码：

```typescript
// 定义接口
interface Person {
  name: string
  age: number
}

// 继承接口
interface Student extends Person {
  grade: number
}

// 实现接口
class StudentInfo implements Student {
  name: string
  age: number
  grade: number
}
```

2. `type`：

   - 主要用于定义复杂的类型别名，可以包含联合类型、交叉类型、元组等。
   - 不支持继承和实现，不能被扩展或实现。
   - 可以使用交叉类型实现类似继承的效果。

示例代码：

```typescript
// 定义类型别名
type Person = {
  name: string
  age: number
}

// 使用交叉类型实现类似继承
type Student = Person & {
  grade: number
}

// 使用类型别名
const student: Student = {
  name: 'Alice',
  age: 18,
  grade: 90,
}
```

总结：

- 如果需要定义对象类型、类类型、函数类型等结构化类型，可以使用 `interface`。
- 如果需要定义复杂的类型别名，可以使用 `type`。
- 如果需要继承其他接口或实现接口，只能使用 `interface`。
- 如果需要合并多个同名的接口，只能使用 `interface`。
- 如果需要使用交叉类型实现类似继承的效果，可以使用 `type`。

### 类组件与函数组件的区别

类组件和函数组件是 React 中两种不同的组件形式，它们有以下区别：

1. 语法形式：
   - 类组件是使用类来定义的组件，继承自 `React.Component` 或其子类，通常包含 `render()` 方法来返回 JSX 元素。
   - 函数组件是使用函数来定义的组件，通过返回 JSX 元素来表示组件的内容。

示例代码：
**类组件：**

```jsx
class ClassComponent extends React.Component {
  render() {
    return <div>Hello, I am a class component.</div>
  }
}
```

**函数组件：**

```jsx
function FunctionComponent() {
  return <div>Hello, I am a function component.</div>
}
```

2. 写法简洁程度：

   - 函数组件相较于类组件，语法更为简洁，只需一个函数定义即可，没有额外的类声明和生命周期方法。
   - 类组件需要定义一个类，并在类中编写 `render()` 方法，相对来说代码较为冗长。

3. 生命周期：
   - 类组件拥有完整的生命周期方法，例如 `componentDidMount`、`componentDidUpdate` 等，可以处理组件的挂载、更新、卸载等操作。
   - 函数组件没有类组件那样的完整生命周期方法，但可以使用 `useEffect` 钩子来处理组件的副作用操作，如模拟生命周期的行为。

示例代码：

**类组件：**

```jsx
class ClassComponent extends React.Component {
  componentDidMount() {
    console.log('Component is mounted.')
  }

  componentDidUpdate() {
    console.log('Component is updated.')
  }

  componentWillUnmount() {
    console.log('Component is unmounted.')
  }

  render() {
    return <div>Hello, I am a class component.</div>
  }
}
```

**函数组件：**

```jsx
function FunctionComponent() {
  React.useEffect(() => {
    console.log('Component is mounted.')
    return () => {
      console.log('Component is unmounted.')
    }
  }, [])

  return <div>Hello, I am a function component.</div>
}
```

4. 使用状态（State）：
   - 在过去，函数组件没有状态（state），只能处理静态的 UI 渲染。
   - 但自 React 16.8 版本起，引入了 `Hooks`，可以让函数组件也拥有状态和其他生命周期行为。

### 父子父子/兄弟组件之间的通信兄弟组件之间的通信

1. 父子组件之间的通信：

   - 父组件通过 props 将数据传递给子组件。
   - 子组件通过调用父组件传递的回调函数，向父组件传递数据或触发某些操作。

2. 兄弟组件之间的通信：

   - 使用共同的父组件作为中介，通过父组件将数据传递给兄弟组件。
   - 也可以使用状态管理工具（如 Redux 或 MobX）来实现兄弟组件之间的通信。

### setState 什么时候同步，异步什么时候同步，异步

1. 同步的情况

- setState 在 setTimeout 中是同步的。
- setState 在原生事件中是同步的，即通过 dom 绑定事件的方式实现。

2. 异步的情况

- setstate 在合成事件中是异步的，这里说的异步实际上是 react 的批量更新，达到了提升性能的目的。
- setstate 在生命周期中是异步的

### diff 算法算法

在 React 中，虚拟 DOM 和 diff 算法是实现高效更新视图的关键技术。

1. **虚拟 DOM：**
   虚拟 DOM 是 React 中的一种轻量级的表示真实 DOM 结构的 JavaScript 对象。当数据发生变化时，React 不直接操作真实 DOM，而是先对比新旧虚拟 DOM，找出需要更新的部分，然后再将更新后的虚拟 DOM 转换成真实 DOM 并更新到页面上。这样的方式避免了直接频繁操作真实 DOM，提高了性能。

2. **Diff 算法：**
   在更新虚拟 DOM 时，React 使用 Diff 算法来高效地找出新旧虚拟 DOM 之间的差异，并只更新发生变化的部分。Diff 算法的核心思想是通过比较新旧虚拟 DOM 的结构，尽量复用已有的 DOM 节点，减少 DOM 操作的次数。

   Diff 算法的过程如下：
   a. 逐层比较虚拟 DOM 的节点，首先对比根节点，然后对比子节点，再对比子节点的子节点，依此类推。
   b. 当比较到同一层级的节点时，React 会使用唯一的 key 属性来判断节点是否需要更新。如果新旧节点的 key 相同，React 认为这是同一个节点，会复用该节点，而不是重新创建。
   c. 如果新旧节点的 key 不同，React 会认为这是不同的节点，会将旧节点从页面中移除，然后创建新的节点并添加到页面上。

   Diff 算法的优势在于尽量减少了真实 DOM 的操作次数，避免了不必要的重绘和回流，从而提高了页面的性能和响应速度。

需要注意的是，虽然 Diff 算法可以高效地更新视图，但在某些特定情况下，也可能会出现性能问题，例如当虚拟 DOM 树过大时。因此，在编写 React 组件时，需要注意避免不必要的渲染和使用合适的优化技巧来提高页面性能。

### 说一下你对说一下你对 react fiber 了解多少？了解多少？react 为什么改成了为什么改成了 fiber 架构？之前的架构有架构？之前的架构有什么问题吗？什么问题吗？

React Fiber 是 React 16 版本引入的一种新的协调算法和架构，用于实现增量渲染和更好的用户交互体验。在了解 React Fiber 之前，我们需要知道 React 之前的架构是基于堆栈调和的。

之前的 React 架构（基于堆栈调和）存在一些问题：

1. **阻塞主线程：** 在 React 之前的架构中，组件的渲染是同步进行的，即每次更新都会阻塞主线程。这对于大型应用或复杂组件来说可能会导致性能问题，使得用户交互不够流畅。

2. **无法中断和恢复渲染：** 在堆栈调和的架构中，一旦开始渲染一个组件，就无法中断它的渲染过程。这导致当组件层级很深时，单次更新可能会导致较长的渲染时间，影响用户体验。

3. **低优先级任务被延迟：** 在堆栈调和的架构中，由于渲染是同步进行的，低优先级的任务（如动画、用户输入响应等）可能会被延迟，从而导致用户感知到的交互延迟。

为了解决上述问题，React 引入了 Fiber 架构：

1. **增量渲染：** React Fiber 引入了增量渲染的概念，将组件的渲染过程分解为多个小任务（fiber），通过优先级调度和时间切片的方式，使得渲染可以被中断和恢复。这样可以将渲染任务分散到多个帧中，避免长时间的渲染阻塞主线程，提高应用的响应能力和用户交互体验。

2. **优先级调度：** Fiber 架构中引入了任务的优先级概念，每个任务都有不同的优先级，高优先级任务可以打断低优先级任务的执行，从而确保高优先级任务的及时响应。这样可以保证低优先级任务不会影响到高优先级任务的执行。

3. **时间切片：** Fiber 架构将渲染任务切分成多个时间片（例如 16 毫秒），每次执行一个时间片的任务，然后将控制权交还给主线程。这样可以使得主线程有机会执行其他任务，同时保证低优先级任务的及时响应。

总结：React Fiber 架构的引入主要是为了解决之前 React 应用在性能和用户交互体验上的一些瓶颈和问题。通过增量渲染、优先级调度和时间切片等技术，使得 React 应用可以更好地适应复杂应用场景，并提供更好的用户体验。

### useMemo 与 useCallback 区别

- useMemo 主要用于缓存值，适用于任何类型的值，例如计算结果、对象、数组等。
- useCallback 主要用于缓存函数，适用于需要传递给子组件的回调函数，以避免不必要的函数重复创建。

### 使用过使用过 webpack 么，讲一下么，讲一下 plugin 与与 loader 的区别的区别

- loader: 文件加载器，能够加载资源文件， 并进行文件的处理
- plugin : c 插件，扩展 webpack 的功能

1. 运行时机上

- loader:运行在打包文件之前
- plugin: 整个编译周期都起作用

2. 在配置上

- loader: 在 module.roules 中配置，作为模块的解析规则，
- plugin: 在 plugin 中单独配置， 每项都是 plugin 实例
  

### webpack 如何提高构建速度

- 多入口情况下，使用 CommonsChunkPlugin 来提取公共代码
- 通过 externals 配置来提取常用库
- 利用 Dllplugin 和 DllReferencePlugin 预编译资源模块， 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来
- 使用 Happypack 实现多线程加速编译
- 使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码
- 拆包
- 使用 HtmlWebpackPlugin 插件来生成 HTML 的模板时候，通过配置属性 minify 进行 html 优化。

### hash，，chunkHash，，contentHash 区别区别

hash、chunkhash 和 contenthash 是用于生成文件名的哈希选项

- hash 适用于开发环境，它会为整个构建过程生成一个唯一的哈希值
- chunkhash 适用于生产环境中的代码分割和按需加载， 每个入口文件和它所依赖的模块都会生成一个独立的 chunkhash 值。
- contenthash 适用于生产环境中希望精确控制缓存的文件内容。
  选择合适的哈希选项可以有效地提高 Webpack 构建的性能和缓存策略。

### webpack 构建流程构建流程

webpack 是一个串行的过程， 从启动到结束会 依次执行以下顺序

- 初始化参数： 从配置文件和 shell 语句中读取和合并参数，得出最终参数
- 开始编译： 用上一步得到的参数 complier 对象，加载所有配置的插件， 执行对象的 run 方法开始执行编译
- 确定入口： 根据配置中的 entry 找出所有入口文件
- 模块化编译： 从入口文件出发， 调用所有配置的 loader 对模块进行编译， 在找出改模块的依赖模块， 再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
- 完成模块编译： 在经过第四步使用 loader 翻译完所有模块后， 得到每个模块被翻译后的最终内容以及他们之间的依赖关系
- 输出资源： 根据入口和模块之间的依赖关系， 组装成一个个包含多个模块的 chunk 再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
- 输出完成： 确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

### 大数据长列表如何优化（虚拟列表）大数据长列表如何优化（虚拟列表）

### 讲一下浏览器缓存（协商缓存、强缓存）

- 强缓存 ：当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。

  1. Expires

  - Exprires 的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。

  2. Cache-Control。

  - private：客户端可以缓存
  - public：客户端和代理服务器都可以缓存
  - max-age=t：缓存内容将在 t 秒后失效
  - no-cache：需要使用协商缓存来验证缓存数据
  - no-store：所有内容都不会缓存。

  ```js
  // 使用 XMLHttpRequest 设置请求头
  var xhr = new XMLHttpRequest()
  xhr.open('GET', '/api/resource')
  xhr.setRequestHeader('Cache-Control', 'max-age=3600')
  xhr.send()

  // 使用 fetch API 设置请求头
  fetch('/api/resource', {
    headers: {
      'Cache-Control': 'max-age=3600',
    },
  })

  // 使用 fetch API 设置请求头
  fetch('https://example.com/api/resource', {
    method: 'GET',
    headers: {
      'If-Modified-Since': 'Sat, 01 Jan 2022 00:00:00 GMT',
      'If-None-Match': '123456789',
    },
  })
    .then(function (response) {
      if (response.status === 200) {
        // 请求成功，处理响应
        return response.text()
      } else if (response.status === 304) {
        // 资源未发生变化，使用缓存数据
      } else {
        // 请求失败，处理错误
        throw new Error(response.status)
      }
    })
    .then(function (data) {
      console.log(data)
    })
    .catch(function (error) {
      console.error(error)
    })
  ```

- 协商缓存： 客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回 304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据

  - Last-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间
  - Etag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标
    - If-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。

  ```js
  // 使用 XMLHttpRequest：

  // 设置 If-Modified-Since 字段
  xhr.setRequestHeader('If-Modified-Since', 'Sat, 01 Jan 2022 00:00:00 GMT')

  // 设置 If-None-Match 字段
  xhr.setRequestHeader('If-None-Match', '123456789')
  ```

  - 优点

    1. 减少了冗余的数据传递，节省宽带流量
    2. 减少了服务器的负担，大大提高了网站性能
    3. 加快了客户端加载网页的速度 这也正是 HTTP 缓存属于客户端缓存的原因。

  - 强制缓存的优先级高于协商缓存

### 输入一个输入一个 url 到页面呈现到浏览器上的全过程到页面呈现到浏览器上的全过程

      1. 浏览器解析地址， 解析出主机名转换成ip 地址
      2. 浏览器先查找本地dns缓存列表， 没有的话向浏览器默认DNS服务器发送查询请求，同时缓存
      3. 浏览器建立一条与目标web服务器的TCP链接（3次握手）
      4. 浏览器向服务器发送一条HTTP请求报文
      5. 服务器向浏览器返回一条HTTP响应报文
      6. 浏览器解析渲染页面
      7. 四次挥手断开连接

### 浏览器渲染过程

1.  解析 html 生产 dom 树
2.  解析 css 生产 cssom 规则树
3.  将 dom 树和 cssom 规则树合并生成渲染成
4.  节点数开始布局， 计算元素的位置和大小
5.  将每个节点渲染到页面中

### 渲染阻塞

当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建 DOM。每次去执行 JavaScript 脚本都会严重地阻塞 DOM 树的构建

- 遵循规则
- CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
- JS 置后：我们通常把 JS 代码放到页面底部，且 JavaScript 应尽量少影响 DOM 的构建。

### TCP 和和 UDP 的区别的区别

TCP（传输控制协议）和 UDP（用户数据报协议）是两种不同的传输层协议，它们在传输数据时有以下区别：

1. **连接性：**

- TCP 是面向连接的协议，通信前需要建立连接，然后进行数据传输，传输完成后再断开连接。
- UDP 是无连接的协议，通信不需要建立连接，每个数据包都是独立的，发送方和接收方不维护连接状态。

2. **可靠性：**

- TCP 提供可靠的数据传输，它使用序号、确认和重传机制来确保数据的完整性和可靠性。如果数据包丢失或损坏，TCP 会重新发送数据，直到对方确认接收到正确的数据。
- UDP 不保证数据传输的可靠性，发送数据后不会等待确认，也不会重新发送数据。如果数据包丢失或损坏，UDP 会直接丢弃，不会重传。

3. **数据量：**

- TCP 适用于大数据量传输，它通过滑动窗口机制来控制发送和接收数据的速度。
- UDP 适用于小数据量传输，因为不需要建立连接和维护状态，适用于实时性要求高、数据量较小的场景。

4. **顺序性：**

- TCP 保证数据的顺序性，发送方按照顺序发送数据，接收方按照顺序接收数据，确保数据包按照发送顺序被接收。
- UDP 不保证数据的顺序性，发送的数据包和接收的数据包的顺序可能不一致。

5. **拥塞控制：**

- TCP 具有拥塞控制机制，通过动态调整传输速率来避免网络拥塞，确保网络稳定。
- UDP 没有拥塞控制机制，发送数据时不会根据网络情况进行调整，容易造成网络拥堵。

6. **应用场景：**

- TCP 适用于对数据可靠性要求较高的场景，如网页浏览、文件传输等。
- UDP 适用于对实时性要求高的场景，如实时游戏、音视频传输等。

总体来说，TCP 适用于可靠传输的场景，而 UDP 适用于实时性要求高、对数据可靠性要求相对较低的场景。在选择使用 TCP 还是 UDP 时，需要根据具体的应用需求来决定。

### 项目中遇到困难，如何解决的项目中遇到困难，如何解决的

- 分析问题
- 查阅文档
- 排查日志和调试
- 尝试不同的解决方案
- 持续学习和积累经验
- 向同事或社区寻求帮助
- 记录解决过程

### 怎么推动你做的技术最大范围落地怎么推动你做的技术最大范围落地

12. 请写出弹出值，并解释为什么（请写出弹出值，并解释为什么（考点：变量提升考点：变量提升））

```js
alert(a) // function a(){ alert(10) }
a()
var a = 3
function a() {
  alert(10) // 10
}
alert(a) // 3
a = 6
a() // Uncaught TypeError: a is not a function    因为此时a不再是函数，而是一个数字6，数字类型不是可调用的。
```

13. 下面下面 t1t1、、t2t2、、t3t3 文案颜色分别是什么（文案颜色分别是什么（考点：考点：CSSCSS 权重权重））

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <style>
    #a p {
      color: blue;
    }
    p span {
      color: red;
    }
    .b:nth-of-type(even) .c {
      /* // 所有索引为偶数的子元素 */
      color: purple;
    }
    p.b:nth-of-type(even):not(.no) .c {
      /* // 所有索引为偶数的子元素（根据子元素类型），并且排除class为"no"的<p>元素，再选择其中所有class为"c"的元素，将其文字颜色设置为绿色。 */
      color: green;
    }
  </style>

  <body>
    <div id="a">
      <p><span class="c">t1</span></p>
      // red
      <p class="b no"><span class="c">t2</span></p>
      // purple
      <p class="b"><span class="c">t3</span></p>
      // red
      <p class="b"><span class="c">t4</span></p>
      // green
    </div>
  </body>
</html>
```

12. 输出顺序（输出顺序（考点：考点：PromisePromise 原原理理解理理解））

```js
Promise.resolve()
  .then(function a() {
    console.log('then1')
    Promise.resolve()
      .then(function b() {
        console.log('then1--1')
        Promise.resolve().then(function c() {
          console.log('then1--3')
        })
        return Promise.resolve()
      })
      .then(function d() {
        console.log('then1--2')
      })
  })
  .then(function e() {
    console.log('then2')
  })
  .then(function e() {
    console.log('then3')
  })
  .then(function e() {
    console.log('then4')
  })
  .then(function e() {
    console.log('then5')
  })

  then1
  then1--1
  then2
  then1--3
  then3
  then4
  then1--2
  then5
```

13. 写出如下代码执行结果（写出如下代码执行结果（考点：考点：thisthis 指向指向））

```js
var length = 10
function fn() {
  console.log(this.length) // window 10  ,  Arguments 2
}
var ichangtou = {
  length: 5,
  method: function (fn) {
    fn()
    arguments[0]()
  },
}
ichangtou.method(fn, 1)
```

5. 实现一个倒计时函数实现一个倒计时函数 countDown, 运行运行 countDown(n) 会开始倒计时，从会开始倒计时，从 n 开开始，每隔始，每隔 1 秒钟在控制台打印一个数字，秒钟在控制台打印一个数字， 一直倒数到一直倒数到 0 停止。停止。
   注：即第
   注：即第 0 秒打印秒打印 n, 第第 1 秒打印秒打印 n - 1 ..., 第第 n 秒打印秒打印 0，， 然后停止打印。然后停止打印。

```js
// 方法一
function countDown(nums) {
  console.log(nums)
  const timer = setInterval(() => {
    nums-- // 倒计时数字减一
    if (nums >= 0) {
      console.log(nums) // 打印当前倒计时的数字
    } else {
      clearInterval(timer)
    }
  }, 1000)
}
countDown(5)

// 方法二

function countDown(n) {
  if (n >= 0) {
    console.log(n) // 打印当前倒计时的数字
    setTimeout(() => countDown(n - 1), 1000) // 递归调用 countDown 函数，并设置 1 秒钟的延迟
  }
}

// 使用例子，倒计时从 5 开始
countDown(5)
```
