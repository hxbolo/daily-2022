# vue.js 设计与实现

## 第 1 章 权衡的艺术

1.1 命令式和声明式

- 命令式框架 => 关注过程
- 声明式框架 => 关注结果
- Vue.js 帮我们封装了过程。因此，我们能够猜到 Vue.js 的内部实
  现一定是命令式的，而暴露给用户的却更加声明式。

  1.2 性能与可维护性的权衡

- 结论： 声明式代码的性能不优于命令式代码的性能。
- 声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗
  1.3 虚拟 DOM 的性能到底如何

* 使用 innerHTML 更新页面的过程是重新构建 HTML 字符串，再重新设置 DOM 元素的 innerHTML 属性，这其实是在说，哪怕我们只更改了一个文字，也要重新设置 innerHTML 属性。而重新设置 innerHTML 属性就等价于**销毁所有旧的 DOM 元素，再全量创建新的 DOM 元素**

  - innerHTML 全量更新
  - 性能因素： 与模板大小有关 页面越大， 性能消耗越大

* 虚拟 DOM 是如何更新页面的。它需要重新创建 JavaScript 对象（虚拟 DOM 树），然后**比较新旧虚拟 DOM，找到变化的元素并更新**

  - 虚拟 DOM 在更新页面只会更新必要的元素
  - 性能因素： 与数据变化量有关

    1.4 运行时和编译时

- Vue.js 3 是一个编译时 + 运行时的框架

## 第 2 章 框架设计的核心要素

2.1 提升用户的开发体验
2.2 控制框架代码的体积

- **DEV** 常量替换为字面量 false，这时我们发现这段分支代码永远都不会执行，因为判断条件始终为假，这段永远不会执行的代码称为 dead code，它不会出现在最终产物中，在构建资源的时候就会被移除，因此在 vue.global.prod.js 中是不会存在这段代码的。

**开发环境中为用户提供友好的警告信息的同时，不会增加生产环境代码的体积**。

2.3 框架要做到良好的 Tree-Shaking

- Tree-Shaking，必须满足一个条件，即模块必须是 ESM（ES Module）**Tree-Shaking 依赖 ESM 的静态结构**
- Tree-Shaking 中的第二个关键点——副作用。如果一个函数调用会产生副作用，那么就不能将其移除

  - 副作用就是，当调用函数的时候会对外部产生影响

    2.4 框架应该输出怎样的构建产物
    2.5 特性开关
    2.6 错误处理

- registerErrorHandler 函数，用户可以使用它注册错误处理程序，然后在 callWithErrorHandling 函数内部捕获错误后，把错误传递给用户注册的错误处理程序
  2.7 良好的 TypeScr ipt 类型支持

## 第 3 章 Vue.js 3 的设计思路

3.1 声明式地描述 UI

```js
// h 函数的返回值就是一个对象，其作用是让我们编写虚拟DOM 变得更加轻松
import { h } from 'vue'

export default {
  render() {
    return h('h1', { onClick: handler }) // 虚拟 DOM
  },
}
```

- 渲染函数
  -Vue.js 会根据组件的 render 函数的返回值拿到虚拟 DOM，然后就可以把组件的内容渲染出来了。

  3.2 初识渲染器

- 作用： 虚拟 DOM 渲染为真实 DOM

  3.3 组件的本质

- ：组件就是一组 DOM 元素的封装

  3.4 模板的工作原理

- 编译器的作用: 将模板编译为渲染函数
- <template> 标签里的内容就是模板内容，编译器会把模板内容编译成渲染函数并添加到 <script> 标签块的组件对象上

```html
<template>
  <div @click="handler">click me</div>
</template>

<script>
  export default {
    data() {
      /* ... */
    },
    methods: {
      handler: () => {
        /* ... */
      },
    },
  }
  14
</script>
```

<!--最终运行代码 -->

```js
export default {
  data() {
    /* ... */
  },
  methods: {
    handler: () => {
      /* ... */
    },
  },

  // 把模板中的内容转换成渲染函数
  render() {
    return h('div', { onClick: handler }, 'click me')
  },
}
```

3.5 Vue.js 是各个模块组成的有机整体

- 组件的实现依赖于渲染器，模板的编译依赖于编译
  器，并且编译后生成的代码是根据渲染器和虚拟 DOM 的设计决定的


## 第 4 章 响应系统的作用与实现