### 什么是闭包

- 一个函数有权访问到另一个函数作用域中的变量的函数
- 特点：

1.  函数嵌套函数
2.  函数内部可以引用外部的参数和变量
3.  参数和变量不会被回收

- 优点

  1. 变量长期驻扎在内存中
  2. 避免造成全局污染
  3. 私有成员的存在

- 缺点: 会照成内存泄漏

- 闭包在 JavaScript 中有着广泛的应用，包括封装变量、保持状态、实现数据私有性以及处理回调和异步操作等方面。通过使用闭包，我们可以编写更加模块化、可维护和安全的代码。

### 变量提升

- 申明的变量和函数会提升到作用域的顶部

变量提升主要有两个方面：

1. **变量声明提升**：在函数作用域内或全局作用域内，使用 `var` 关键字声明的变量会被提升到函数或全局作用域的顶部，但它们的赋值保留在原始位置。这意味着你可以在变量声明之前引用变量，但它的值会是 `undefined`。

   ```javascript
   console.log(x) // 输出 undefined
   var x = 5
   ```

   上述代码中，变量 `x` 的声明被提升，但赋值 `x = 5` 并没有提升，所以在声明之前输出 `x` 会得到 `undefined`。

2. **函数声明提升**：使用 `function` 关键字声明的函数会被整体提升到其所在作用域的顶部，包括函数体。这允许在函数声明之前调用函数。

   ```javascript
   foo() // 输出 "Hello, world!"
   function foo() {
     console.log('Hello, world!')
   }
   ```

   上述代码中，函数 `foo` 被整体提升，所以可以在声明之前调用。

需要注意的是，使用 `let` 和 `const` 声明的变量也会被提升，但与 `var` 不同，它们不会被初始化为 `undefined`，而是处于 "暂时性死区"（Temporal Dead Zone，TDZ）中，直到真正的声明出现才可以访问它们。

### 如何封装一个组件，需要注意写什么

solt / props/ emit

### 任务如何分派给组员

当拆分前端任务给团队成员时，需要经过以下步骤：

1. **需求分析**：仔细审查项目需求，确保充分理解项目的目标和要求。

2. **任务分类**：将任务按照不同的模块或类型进行分类，如核心功能、UI 设计、性能优化、测试等。

3. **任务优先级**：确定任务的优先级，优先处理关键功能和紧急任务。

4. **任务分配**：根据团队成员的技能和可用性，将任务分发给适当的人员。

5. **明确任务描述**：确保每个任务都有清晰的描述，包括要求、预期结果和截止日期。

6. **定期沟通**：建立定期的沟通渠道，确保团队成员能够分享进展并解决问题。

7. **代码审查**：鼓励团队成员进行代码审查，以确保代码质量和一致性。

8. **测试与反馈**：在任务完成后进行测试，根据测试结果提供反馈并进行修复。

9. **集成与部署**：将各个任务的成果整合到项目中，并进行部署。

10. **文档撰写**：编写项目文档，记录项目架构、代码结构和使用说明。

11. **回顾与改进**：在项目结束后进行回顾，总结成功因素和问题，并制定改进计划。

### webpack 热更新原理（HMR）

webpack-dev-serve 启动本地服务

1. 本地 serve 启动服务让浏览器可以请求本地静态资源
2. serve 启动后， 启动 websocket 服务，简历本地服务与浏览器双向通信

3. 浏览器通过 SSE(serve-sent Evnets)接收 server 端关于更新更新的消息
4. 浏览器通过 HotModuleReplacementPlugin 布置在项目中的代码发送 ，json 请求来获取最新资源
5. 通过 hash 值判断更新模块（hotcheck）

### souce map 将打包之后的代码映射给源码

- eval: 使用包裹模块代码
- source map : 产生 map 文件
- cheap： 不包含列信息 -》 只定位行
- inline: 将 map 文件作为 data url 嵌入， 不单独生成.map 文件
- module： 包含 loader 的 source map

在**devtool**中指定方式 =》 ’eval‘ ， ’source map ‘ ,'inline-source-map' , 会产生.js 文件同时生成对应.map 文件

### webpack 优化

1.  压缩代码

- 多进程并行压缩
  - webpack-paralle-uglify-plugin
  - terser-webpack-plugin 开启 parallel 参数

2. 图片压缩
   - 配置 image-webpack-loader
3. 缩小打包作用域
   - exclude/include (确定 loader 规则范围)
4. **Tree shaking**

   - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的 bundle 中去掉(只能对 ES6 Modlue 生效) 开发中尽可能使用 ES6 Module 的模块，提高 tree shaking 效率

5. **Scope hoisting（作用域提升）**
   - **构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大**。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突
6. 代码分割
   webpack 可将代码分割为 chunks 语块运行时在加载
7. **预编译资源模块**:

- 利用 Dllplugin 和 DllReferencePlugin 预编译资源模块， 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来

8.  **实现多线程加速编译**

- 使用 Happypack 实现多线程加速编译 (3.0)
- thread loader (4.0)

9. 分包 通过 externals 配置来提取常用库

- 将 react ,等基础包， 通过 cdn 引入， 不打包进 bundle.js
- 使用 html-webpack-externals-plugin

### 构建包功能设计

1. 基础配置（webpack.base.js）

   - 资源解析：ES6， react， css, less， 图片， 字体
   - 样式增强：
     - css 前缀对齐
     - css px 转换为 em
   - 目录清理
   - 多页面打包
   - 命令行信息显示优化
   - 错误捕获与处理
   - css 提取

2. 开发阶段配置

   - 代码热更新（HMR）: CSS， js
   - source map

3. 生产阶段配置

   - 代码压缩
   - 文件指纹
   - tree shaking
   - sopce hoisting
   - **速度优化**：基础包 CDN
   - **体积优化**： 代码分割

4. ssr 配置

## 常见 ts 面试题

### TypeScript 中 type 和 interface 的区别?

相同点：

1. 都可以描述 '对象' 或者 '函数'
2. 都允许拓展(extends)
   不同点：
3. type 可以声明基本类型，联合类型，元组
4. type 可以使用 typeof 获取实例的类型进行赋值
5. 多个相同的 interface 声明可以自动合并
   使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’

### 对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？

public: 成员都默认为 public，被此限定符修饰的成员是可以被外部访问；
private: 被此限定符修饰的成员是只可以被类的内部访问；
protected: 被此限定符修饰的成员是只可以被类的内部以及类的子类访问;
readonly: 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。
