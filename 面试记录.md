### 什么是闭包

- 一个函数有权访问到另一个函数作用域中的变量的函数
- 特点：

1.  函数嵌套函数
2.  函数内部可以引用外部的参数和变量
3.  参数和变量不会被回收

- 优点

  1. 变量长期驻扎在内存中
  2. 避免造成全局污染
  3. 私有成员的存在

- 缺点: 会照成内存泄漏

- 闭包在 JavaScript 中有着广泛的应用，包括封装变量、保持状态、实现数据私有性以及处理回调和异步操作等方面。通过使用闭包，我们可以编写更加模块化、可维护和安全的代码。

### 变量提升

- 申明的变量和函数会提升到作用域的顶部

变量提升主要有两个方面：

1. **变量声明提升**：在函数作用域内或全局作用域内，使用 `var` 关键字声明的变量会被提升到函数或全局作用域的顶部，但它们的赋值保留在原始位置。这意味着你可以在变量声明之前引用变量，但它的值会是 `undefined`。

   ```javascript
   console.log(x) // 输出 undefined
   var x = 5
   ```

   上述代码中，变量 `x` 的声明被提升，但赋值 `x = 5` 并没有提升，所以在声明之前输出 `x` 会得到 `undefined`。

2. **函数声明提升**：使用 `function` 关键字声明的函数会被整体提升到其所在作用域的顶部，包括函数体。这允许在函数声明之前调用函数。

   ```javascript
   foo() // 输出 "Hello, world!"
   function foo() {
     console.log('Hello, world!')
   }
   ```

   上述代码中，函数 `foo` 被整体提升，所以可以在声明之前调用。

需要注意的是，使用 `let` 和 `const` 声明的变量也会被提升，但与 `var` 不同，它们不会被初始化为 `undefined`，而是处于 "暂时性死区"（Temporal Dead Zone，TDZ）中，直到真正的声明出现才可以访问它们。

### 如何封装一个组件，需要注意写什么

solt / props/ emit

### 任务如何分派给组员

当拆分前端任务给团队成员时，需要经过以下步骤：

1. **需求分析**：仔细审查项目需求，确保充分理解项目的目标和要求。

2. **任务分类**：将任务按照不同的模块或类型进行分类，如核心功能、UI 设计、性能优化、测试等。

3. **任务优先级**：确定任务的优先级，优先处理关键功能和紧急任务。

4. **任务分配**：根据团队成员的技能和可用性，将任务分发给适当的人员。

5. **明确任务描述**：确保每个任务都有清晰的描述，包括要求、预期结果和截止日期。

6. **定期沟通**：建立定期的沟通渠道，确保团队成员能够分享进展并解决问题。

7. **代码审查**：鼓励团队成员进行代码审查，以确保代码质量和一致性。

8. **测试与反馈**：在任务完成后进行测试，根据测试结果提供反馈并进行修复。

9. **集成与部署**：将各个任务的成果整合到项目中，并进行部署。

10. **文档撰写**：编写项目文档，记录项目架构、代码结构和使用说明。

11. **回顾与改进**：在项目结束后进行回顾，总结成功因素和问题，并制定改进计划。

### webpack 热更新原理（HMR）

webpack-dev-serve 启动本地服务

1. 本地 serve 启动服务让浏览器可以请求本地静态资源
2. serve 启动后， 启动 websocket 服务，简历本地服务与浏览器双向通信

3. 浏览器通过 SSE(serve-sent Evnets)接收 server 端关于更新更新的消息
4. 浏览器通过 HotModuleReplacementPlugin 布置在项目中的代码发送 ，json 请求来获取最新资源
5. 通过 hash 值判断更新模块（hotcheck）

### souce map 将打包之后的代码映射给源码

- eval: 使用包裹模块代码
- source map : 产生 map 文件
- cheap： 不包含列信息 -》 只定位行
- inline: 将 map 文件作为 data url 嵌入， 不单独生成.map 文件
- module： 包含 loader 的 source map

在**devtool**中指定方式 =》 ’eval‘ ， ’source map ‘ ,'inline-source-map' , 会产生.js 文件同时生成对应.map 文件

### webpack 优化

1.  压缩代码

- 多进程并行压缩
  - webpack-paralle-uglify-plugin
  - terser-webpack-plugin 开启 parallel 参数

2. 图片压缩
   - 配置 image-webpack-loader
3. 缩小打包作用域
   - exclude/include (确定 loader 规则范围)
4. **Tree shaking**

   - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的 bundle 中去掉(只能对 ES6 Modlue 生效) 开发中尽可能使用 ES6 Module 的模块，提高 tree shaking 效率

5. **Scope hoisting（作用域提升）**
   - **构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大**。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突
6. 代码分割
   webpack 可将代码分割为 chunks 语块运行时在加载
7. **预编译资源模块**:

- 利用 Dllplugin 和 DllReferencePlugin 预编译资源模块， 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来

8.  **实现多线程加速编译**

- 使用 Happypack 实现多线程加速编译 (3.0)
- thread loader (4.0)

9. 分包 通过 externals 配置来提取常用库

- 将 react ,等基础包， 通过 cdn 引入， 不打包进 bundle.js
- 使用 html-webpack-externals-plugin

### 构建包功能设计

1. 基础配置（webpack.base.js）

   - 资源解析：ES6， react， css, less， 图片， 字体
   - 样式增强：
     - css 前缀对齐
     - css px 转换为 em
   - 目录清理
   - 多页面打包
   - 命令行信息显示优化
   - 错误捕获与处理
   - css 提取

2. 开发阶段配置

   - 代码热更新（HMR）: CSS， js
   - source map

3. 生产阶段配置

   - 代码压缩
   - 文件指纹
   - tree shaking
   - sopce hoisting
   - **速度优化**：基础包 CDN
   - **体积优化**： 代码分割

4. ssr 配置

## 常见 ts 面试题

### TypeScript 中 type 和 interface 的区别?

相同点：

1. 都可以描述 '对象' 或者 '函数'
2. 都允许拓展(extends)
   不同点：
3. type 可以声明基本类型，联合类型，元组
4. type 可以使用 typeof 获取实例的类型进行赋值
5. 多个相同的 interface 声明可以自动合并
   使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’

### 对 TypeScript 类中成员的 public、private、protected、readonly 修饰符的理解？

public: 成员都默认为 public，被此限定符修饰的成员是可以被外部访问；
private: 被此限定符修饰的成员是只可以被类的内部访问；
protected: 被此限定符修饰的成员是只可以被类的内部以及类的子类访问;
readonly: 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。

### 移动端优化

在移动端开发中，优化至关重要，以确保应用程序的性能、用户体验和可用性。以下是一些移动端优化的关键方面：

1. **响应式设计：** 使用响应式设计原则，确保您的应用能够适应不同尺寸和分辨率的移动设备。使用媒体查询和弹性布局来实现响应式布局。

2. **图像优化：** 图像通常占用大量的带宽和存储空间。使用适当的图像格式（如 WebP），并使用图像压缩工具（如 ImageOptim）来减小图像文件的大小。还可以使用`<picture>`元素和`srcset`属性来提供不同分辨率的图像。

3. **减少 HTTP 请求：** 减少页面加载时的 HTTP 请求次数。合并和压缩 CSS 和 JavaScript 文件，使用 CSS Sprites 合并图像，以减少文件请求次数。

4. **延迟加载：** 仅加载当前屏幕上可见的内容，而不是一次性加载所有内容。这可以通过懒加载技术来实现，特别是对于图片和其他媒体资源。

5. **代码优化：** 精简和优化 JavaScript 和 CSS 代码，以减小文件大小。删除不需要的代码和注释，避免使用过多的第三方库和插件。

6. **使用本地存储：** 使用本地存储（如 LocalStorage 和 SessionStorage）来缓存数据，减少对服务器的请求，提高加载速度。

7. **减少动画和过渡：** 虽然动画和过渡可以增强用户体验，但要谨慎使用，以避免占用过多的 CPU 和内存资源。

8. **优化字体：** 选择合适的字体，并将字体文件进行子集化，以减小字体文件的大小。

9. **使用 CDN：** 使用内容分发网络（CDN）来提供静态资源，以减少加载时间并提高性能。

10. **启用浏览器缓存：** 使用 HTTP 缓存头来启用浏览器缓存，以减少重复加载相同资源。

11. **性能测试：** 使用工具如 Google PageSpeed Insights 或 Lighthouse 进行性能测试，以发现和解决性能问题。

12. **减少重绘和回流：** 避免频繁的 DOM 操作，以减少浏览器的重绘（Repaint）和回流（Reflow）。

13. **网络请求优化：** 使用 HTTP/2 协议来减少网络请求的延迟。还可以使用数据压缩和资源预加载等技术来优化网络请求。

14. **错误处理：** 实现良好的错误处理机制，以处理网络请求失败、异常和其他错误情况，以提供更好的用户体验。

15. **监控和分析：** 使用监控工具和分析工具来监视应用程序的性能，以及用户行为，以及帮助识别和解决问题。

综上所述，移动端优化涉及多个方面，包括资源加载、代码优化、响应性设计和性能测试等。通过采用这些最佳实践，可以提高您的移动应用程序的性能和用户体验。

### string 静态方法，实例方法

在 JavaScript 中，`String`对象具有许多静态方法和实例方法，这些方法用于操作字符串数据。以下是一些常用的`String`静态方法和实例方法：

**静态方法（String 静态方法，通过`String`对象直接调用）：**

1. **`String.fromCharCode()`：** 将一组 Unicode 值转换为字符串。

   ```javascript
   String.fromCharCode(72, 101, 108, 108, 111) // 返回 "Hello"
   ```

2. **`String.fromCodePoint()`：** 将一组 Unicode 码点转换为字符串。

   ```javascript
   String.fromCodePoint(72, 101, 108, 108, 111) // 返回 "Hello"
   ```

3. **`String.raw()`：** 用于获取一个模板字符串的原始字符串形式。

   ```javascript
   String.raw`Hi\n${2 + 3}!` // 返回 "Hi\\n5!"
   ```

4. **`String.prototype.toString()`：** 返回字符串对象的原始值的字符串表示。

   ```javascript
   const str = new String('Hello')
   str.toString() // 返回 "Hello"
   ```

**实例方法（String 实例方法，通过字符串实例调用）：**

1. **`charAt(index)`：** 返回指定索引位置的字符。

   ```javascript
   'Hello'.charAt(1) // 返回 "e"
   ```

2. **`charCodeAt(index)`：** 返回指定索引位置的字符的 Unicode 值。

   ```javascript
   'Hello'.charCodeAt(0) // 返回 72 (字符 "H" 的Unicode值)
   ```

3. **`concat(...strings)`：** 连接字符串，返回新的字符串。

   ```javascript
   'Hello'.concat(' ', 'World') // 返回 "Hello World"
   ```

4. **`indexOf(substring, fromIndex)`：** 返回指定子字符串第一次出现的位置。

   ```javascript
   'Hello, World'.indexOf('World') // 返回 7
   ```

5. **`slice(start, end)`：** 从字符串中提取部分字符，返回新的字符串。

   ```javascript
   'Hello, World'.slice(0, 5) // 返回 "Hello"
   ```

6. **`split(separator, limit)`：** 将字符串拆分为子字符串数组。

   ```javascript
   'apple,banana,orange'.split(',') // 返回 ["apple", "banana", "orange"]
   ```

7. **`substr(start, length)`：** 从指定位置开始截取指定长度的字符串。

   ```javascript
   'Hello, World'.substr(7, 5) // 返回 "World"
   ```

8. **`substring(start, end)`：** 返回从指定开始索引到指定结束索引之间的字符串。

   ```javascript
   'Hello, World'.substring(0, 5) // 返回 "Hello"
   ```

### 数组的方法

### diff 算法

### vue 原理

### computed 原理

### 居中布局

### vue 父子之间的生命周期

**父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted**

### vue 父子通信

### js 基础类型

### 如何固定移动端页面， 手指放大缩小

在移动端，要禁止用户手指放大或缩小页面，您可以使用以下方法之一：

1. **Viewport Meta 标签：** 在 HTML 文档的头部，使用 Viewport Meta 标签来设置页面的初始缩放级别，从而禁止用户手动缩放。将以下代码添加到`<head>`部分：

   ```html
   <meta
     name="viewport"
     content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
   />
   ```

   上述代码中的`user-scalable=no`会阻止用户手动缩放页面。

2. **CSS 属性：** 您可以通过 CSS 来控制页面的缩放行为。以下是一些样式示例：

   ```css
   /* 禁止用户缩放 */
   body {
     touch-action: manipulation;
   }

   /* 禁止双击放大 */
   body {
     touch-action: pan-x pan-y;
   }
   ```

   这些 CSS 样式可以在`<style>`标签中或外部 CSS 文件中使用。

### H5 新增的标签

<article><article>  <!--定义页面独立内容区域-->
<aside></aside>  <!--定义页面侧边栏内容-->
<header></header>  <!--定义页面的头部区域-->
<footer></footer>  <!--定义页面的尾部区域-->
<mark></mark>  <!--定义带记号的文本-->
<nav></nav>  <!--定义页面的导航栏区域-->
<progress></progress>  <!--定义一个进度条-->
<ruby><ruby>  <!--定义ruby注释-->
<time></time>  <!--定义日期或时间-->

### 在浏览器中如何展示小于 12px 的字体

1. zoom
2. -webkit-transform

```css
.span1 {
  font-size: 12px;
  display: inline-block;
  zoom: 0.8; // zoom
  -webkit-transform: scale(0.8); //  -webkit-transform
}
```

### 内存泄露怎么解决

1. **未正确清理事件处理器** 向 DOM 元素添加事件处理器时， 如果不适当地删除这些事件处理器，它们会持有对 DOM 的引用，妨碍垃圾回收器释放相关的内存。
   **解决方法**：在不再需要事件处理器时，务必使用 removeEventListener 来移除它们。

```js
// 错误的示例：未删除事件处理器
const button = document.querySelector('#myButton')

button.addEventListener('click', function () {
  // 一些操作
})

// 忘记删除事件处理器
button.removeEventListener('click', ??);
```

2. **循环引用** 当两个或多个对象相互引用时，即使你不再使用它们，它们也无法被垃圾回收。
   **解决方法**：确保在不再需要对象时，将其引用设置为 null，打破循环引用。

```js
function createObjects() {
  const obj1 = {}
  const obj2 = {}

  obj1.ref = obj2
  obj2.ref = obj1

  // 手动打破循环引用
  obj1.ref = null
  obj2.ref = null

  return 'Objects created'
}
```

3. **未释放大型数据结构** 处理大型数据集合时，未释放这些数据结构可能导致内存泄漏
   **解决方法**：当你不再需要大型数据结构时，将其设置为 null 以释放内存。

```js
function loadLargeData() {
  largeData = [...Array(1000000).keys()]

  // 使用largeData后
  // 不再需要它
  largeData = null
}
```

4. **未正确清理定时器和间隔器** 使用 setTimeout 和 setInterval 创建定时器和间隔器时，如果不及时清理它们，它们会持续运行，可能导致内存泄漏。
   **解决方法**：在不再需要定时器或间隔器时，使用 clearTimeout 和 clearInterval 来清理它们。

```js
// 错误的示例：未清理定时器
let timer

function startTimer() {
  timer = setInterval(function () {
    // 一些操作
  }, 1000)
}

startTimer()

// 忘记清理定时器
clearInterval(timer)
```

5. **使用闭包保留对外部作用域的引用** 闭包可以访问其父作用域的变量。如果不小心，闭包可能会保留对外部作用域的引用，导致外部作用域的变量无法被垃圾回收。
   **解决方法**：在不再需要闭包时，确保解除对外部作用域的引用。

```js
function createClosure() {
  const data = '敏感数据'

  return function () {
    console.log(data)
  }
}

let closure = createClosure()

// 在不再需要闭包时，解除引用
closure = null
```

### vue2.0 中如何更新数组数据

1. **Vue.set** 可以设置对象或数组的值，通过 key 或数组索引，可以触发视图更新

```js
Vue.set(array, indexOfItem, newValue)
Vue.set(obj, keyOfItem, newValue)
```

2. **vm.items.splice(0)**

Vue 提供了如下的数组的变异方法，可以触发视图更新

```js
push()
pop()
shift()
unshift()
splice()
sort()
reverse()
```
