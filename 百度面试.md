### pinia 和 vuex 的区别

pinia 和 vuex 都是状态管理工具， 都用在 vue 的应用中

- 响应式： vuex 使用在 2.0 中修改状态必须同步的，pinia 是 vue3.0 中，可以支持异步操作，pinia 中只有 state、getter、action，抛弃了 Vuex 中的 Mutation

- 类型安全： vuex 也支持 TypeScript，但在一些情况下，类型推导可能相对较复杂， 没有类型检查， Pinia 在设计上更加友好地支持 TypeScript，提供了更好的类型推导 TypeScript 集成

- 体积上： vuex 相对说体积更加庞大， pinia 体积小巧

### jsbridge 使用哪种方式

- 介绍
  h5 经常会用到 native 的功能， 如二维码扫描， 调用原生页面， 获取用户信息，同时 native 也需要想 web 发送推送，更新等， JavaScript 是运行在单独的 JS Context 中（Webview 容器、JSCore 等），与原生有运行环境的隔离，所以需要有一种机制实现 Native 端和 Web 端的双向通信，这就是 JSBridge：**以 JavaScript 引擎或 Webview 容器作为媒介，通过协定协议进行通信，实现 Native 端和 Web 端双向通信的一种机制**。

- jsb 原理
  1. 将 native 端原生接口封装成 JavaScript 接口
  2. 将 web 端 JavaScript 接口封装成原生接口

### web -> native

- 拦截 webview 请求的 URL Schema
  Native 加载 WebView 之后，Web 发送的所有请求都会经过 WebView 组件，所以 Native 可以重写 WebView 里的方法，从来拦截 Web 发起的请求，我们对请求的格式进行判断：

  1. 如果符合我们自定义的 URL Schema，对 URL 进行解析，拿到相关操作、操作，进而调用原生 Native 的方法
  2. 如果不符合我们自定义的 URL Schema，我们直接转发，请求真正的服务

  Web 发送 URL 请求的方法有这么几种：

  1. a 标签
  2. location.href
  3. 使用 iframe.src
  4. 发送 ajax 请求

  这些方法，a 标签需要用户操作，location.href 可能会引起页面的跳转丢失调用，发送 ajax 请求 Android 没有相应的拦截方法，所以使用 iframe.src 是经常会使用的方案：

  1. 安卓提供了 shouldOverrideUrlLoading 方法拦截
  2. UIWebView 使用 shouldStartLoadWithRequest，WKWebView 则使用 decidePolicyForNavigationAction

- 向 webview 中注入 JS API
  这个方法会通过 webView 提供的接口，App 将 Native 的相关**接口注入到 JS 的 Context（window）的对象中**，一般来说这个对象内的方法名与 Native 相关方法名是相同的，Web 端就可以直接在全局 window 下使用这个暴露的全局 JS 对象，进而调用原生端的方法。

### 秒杀活动怎么写， 怎么交互， 怎么监听按钮置灰（商品抢完数据的变化）

- 页面展示

  1. 需要分为静态页面（商品详情、数据等是固定的）和动态 js 按钮
  2. 静态页面放到 cdn 中，减少不必要的服务端请求
  3. 动态生成随机下单页面的 URL：为了避免用户直接访问下单 URL,需要将 URL 动态化，用随机数作为参数，只能秒杀开始的时候才生成。

- 按钮置灰逻辑
  1. 根据倒计时去设置按钮置灰
  2. 开始抢购时间中按钮高亮， 但是需要设置一个定时器去轮询接口查询秒杀是否完成，当秒杀结束，关闭定时器，按钮置灰

### new

- 创建一个空对象
- 将这个对象指向构造函数
- 执行这个构造函数
- 返回这个对象

```js
function myNew() {
  let obj = {}
  let Con = [].shift.call(arguments)
  obj.__proto__ = Con.prototype
  const res = Con.call(obj, arguments)
  return res instanceof obj ? res : obj
}
```

### this 指向

- 全局上下文 中， this 指向 window 对象
- 在函数调用取决于调用方式， 通过对象调用指向这个方法对象， 直接调用，指向 window
- 箭头函数 指向箭头函数创建是的作用域的 this
- call， apply, bind 是可以修改 this，指向的

### ts interface/ type 区别

- 相同点

  1. 都可以描述一个对象或者函数

  ```js
    interface example{
      name: string
      age: number
    }

    interface exmFun {
      (name:string, age: number): void
    }

    type example = {
      name: string
      age: number
    }

    type exmFun= (name:string, age: number) => void
  ```

  2. 都可以继承 extends

  ```js
  type exampletype1 = {
    name: string,
  }

  interface exampleInterface1 {
    name: string;
  }

  type exampletype2 = exampletype1 & { age: number }
  type exampletype2 = exampleInterface1 & { age: number }

  interface exampleInterface2 extends exampletype1 {
    age: number;
  }
  interface exampleInterface2 extends exampleInterface1 {
    age: number;
  }
  ```

- 不同点
  1. type 可以声明类型别名， 联合类型， 元组等
  2. type 语句中可以使用 typeof 获取实例的类型进行赋值
  3. interface 可以声明合并

### vite 和 webpack 区别

1. 构建方式不同：**Vite 利用 ES Modules 的特性进行构建**，每个文件都是一个独立的模块，开发过程中只需要编译修改的文件，不需要每次都编译整个项目；而 Webpack **采用静态分析的方式进行构建，需要分析整个项目中的依赖关系，**每次修改后需要重新编译整个项目\*\*。
2. 开发体验不同：Vite 支持快速的热更新和即时预览，开发者可以在修改代码的同时，立即在浏览器中查看到最新效果；而 Webpack 需要重新编译后才能查看最新效果。
3. 对 Vue 的支持：Vite 是 Vue.js 官方推荐的开发工具，内置了对 Vue 单文件组件的支持，可以直接在浏览器中运行 Vue 组件；而 Webpack 需要通过插件等方式进行支持。
4. 总体来说，Vite 更适合于轻量级的应用，对于 Vue 单文件组件的支持更加完善，而 Webpack 则更适合于复杂的应用，可以通过插件等方式进行更加灵活的配置
5. vite 支持热重载

### webpack 中 splitChunks 分包怎么使用

Webpack 的 splitChunks 插件用于将代码拆分成多个块，有助于提高应用性能。通过将共享的代码提取到单独的文件，可以减小每个页面加载的文件大小，实现更快的加载速度
splitChunks 配置

```js
splitChunks: {
  // 表示选择哪些 chunks 进行分割，可选值有：async，initial和all
  chunks: "async",
  // 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。
  minSize: 30000,
  // 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。
  minChunks: 1,
  // 表示按需加载文件时，并行请求的最大数目。默认为5。
  maxAsyncRequests: 5,
  // 表示加载入口文件时，并行请求的最大数目。默认为3。
  maxInitialRequests: 3,
  // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js
  automaticNameDelimiter: '~',
  // 设置chunk的文件名。默认为true。当为true时，splitChunks基于chunk和cacheGroups的key自动命名。
  name: true,
  // cacheGroups 下可以可以配置多个组，每个组根据test设置条件，符合test条件的模块，就分配到该组。模块可以被多个组引用，但最终会根据priority来决定打包到哪个组中。默认将所有来自 node_modules目录的模块打包至vendors组，将两个以上的chunk所共享的模块打包至default组。
  cacheGroups: {
      vendors: {
          test: /[\\/]node_modules[\\/]/,
          priority: -10
      },
      //
  default: {
          minChunks: 2,
          priority: -20,
          reuseExistingChunk: true
      }
  }
}

```

1. 模块在代码中被复用或者来自 node_modules 文件夹
2. 模块的体积大于等于 30kb（压缩之前）
3. 当按需加载 chunks 时，并行请求的最大数量不能超过 5
4. 页面初始加载时，并行请求的最大数量不能超过 3

### promise.all 修改获取获取全部错误的返回

Promise.allSettled 返回一个在所有给定的 Promise 都已经被解决或被拒绝后决议的 Promise，并且会在所有 Promise 被处理完后返回一个包含每个 Promise 结果的数组，不论是解决还是拒绝。

```js
const promises = [
  Promise.resolve(1),
  Promise.reject('Error 1'),
  Promise.reject('Error 2'),
]

Promise.allSettled(promises).then((results) => {
  const rejectedReasons = results
    .filter((result) => result.status === 'rejected')
    .map((result) => result.reason)
  console.log(rejectedReasons, '=====', results) // 输出所有被拒绝的原因数组
})
```

6. 图片懒加载和预加载
7. defer 和 async


除了使用`setInterval`定时器，还有其他方式可以实现每隔2秒打印数组内容。

一种方法是使用递归和`setTimeout`函数来实现。下面是一个示例代码：

```javascript
const array = [1, 2, 3, 4, 5];
let index = 0;

function printNextElement() {
  if (index < array.length) {
    console.log(array[index]);
    index++;
    setTimeout(printNextElement, 2000);
  }
}

printNextElement();
```

在这个例子中，我们定义了一个`printNextElement`函数，它首先检查索引是否小于数组的长度。如果是，它打印当前元素，增加索引，并通过`setTimeout`函数在2秒后再次调用`printNextElement`函数。

通过递归调用`printNextElement`函数，我们可以实现每隔2秒打印数组中的内容。

另一种方法是使用`async/await`和`Promise`来实现。下面是一个示例代码：

```javascript
const array = [1, 2, 3, 4, 5];

async function printArrayWithDelay() {
  for (let i = 0; i < array.length; i++) {
    console.log(array[i]);
    await new Promise(resolve => setTimeout(resolve, 2000));
  }
}

printArrayWithDelay();
```

在这个例子中，我们定义了一个名为`printArrayWithDelay`的异步函数。通过使用`for`循环遍历数组，我们打印每个元素，并使用`await`关键字等待2秒钟，然后继续下一个循环。

通过使用`async/await`和`Promise`，我们可以实现每隔2秒打印数组中的内容。


- 这个岗位所在的部门是负责小红书哪一块的业务？
- 如果有幸拿到offer，我需要准备哪些技术知识来更快的融入工作环境？
