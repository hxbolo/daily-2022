### get 和 post区别
1. get 通过URL传输， post放在request body 中
2. get请求有URL长度限制， post没有
3. get 比post 安全， 因为get 参数直接暴露在URL中， 不能传递敏感信息
4. get 请求只能进行url编码， post 支持多种编码
5. get 请求参数会被完整的保留在浏览器的记录中， post 不会

### tcp / udp
1. tcp是面向连接的， udp是无线连接的即发生数据前不需要连接
2. tcp 提供可靠的服务，通过tcp连接传送的数据， 不丢失， 不重复， 
    udp: 尽可能交付， 不保证可靠交付
3. TCP是面向字节流，UDP面向报文
4. tcp 1对1  udp 1对1 1对多
5. tcp 首部较大为20字节， udp 只有8字节



### 浏览器的缓存（http 缓存）
1. 浏览器缓存分为 强缓存和协商缓存
2. 强缓存 相关字段 expire ，cache-control, 如果expire ，cache-control同时存在， cache-control 优先级高于 expire
3. 协商缓存  相关字段， last-modified ， etag

  ```html
  1.使用cache-control标头来设置每个资源的缓存策略。

  2.使用ETags来验证缓存的资源，并确保它们是最新的。

  3.使用Last-Modified标头来确定资源的最后修改时间，必要时提供陈旧的内容。

  4.利用公共和私人缓存来提高性能。

  ```

  - 什么是http缓存
    - HTTP缓存是一种存储和重复使用网络资源以提高性能的机制。当一个网络资源被缓存时，后续的请求可以更快得到服务，因为该资源不需要再次从服务器上检索出来。
  - HTTP缓存是如何工作的？
    - HTTP缓存的工作原理是将网络资源存储在一个缓存中，这是一个临时的存储位置。当对一个缓存资源提出请求时，首先检查缓存，看该资源是否可用。如果是，则返回缓存的副本；如果不是，则向服务器查询该资源，并将响应存储在缓存中供将来使用。
  - 使用HTTP缓存的好处有哪些？
    - 使用HTTP缓存有很多好处，包括提高性能、减少带宽使用和降低服务器负载。缓存还可以在服务器发生故障时提供一个备份副本，从而提高资源的可用性。

### 在地址栏中输入一个URL会发生什么
1. 浏览器解析地址， 解析出主机名转换成ip 地址
2. 浏览器先查找本地dns缓存列表， 没有的话向浏览器默认DNS服务器发送查询请求，同时缓存
3. 浏览器建立一条与目标web服务器的TCP链接（3次握手）
4. 浏览器向服务器发送一条HTTP请求报文
5. 服务器向浏览器返回一条HTTP响应报文
6. 浏览器解析渲染页面
7. 四次挥手断开连接


- 浏览器会开启一个线程处理， 同时在远程DNS服务器上启动一个DNS 查询， 让浏览器获得请求对应的IP地址
- 浏览器于远程web服务器通过TCP三次握手建立TCP/IP链接。 该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，然后服务器响应并接受客户端的请求，最后由客户端发出该请求已经被接受的报文
-  一旦TCP/IP连接建立，浏览器会通过该连接向远程服务器发送HTTP的GET请求。远程服务器找到资源并使用HTTP响应返回该资源
- 此时，Web服务器提供资源服务，客户端开始下载资源。


https://juejin.cn/post/6844903784229896199#heading-4
https://juejin.cn/post/6844904054074654728#comment
1. DNS 解析:将域名解析成 IP 地址
  - 在客户端输入 URL 后，会有一个递归查找的过程，从浏览器缓存中查找->本地的hosts文件查找->找本地DNS解析器缓存查找->本地DNS服务器查找，这个过程中任何一步找到了都会结束查找流程。
2. TCP 连接：TCP 三次握手
  - 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
  - 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
  - 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 断开连接：TCP 四次挥手
  - 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
  - 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
  - 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
  - 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)




### 浏览器在生成页面的时候，会生成那两颗树？
  - Dom树和 Cssom规则树
  - 当浏览器收到服务相对应的html 文档后， 会遍历文档节点， 生成DOM树， CSSOM 规则树由浏览器解析css文件生成


### 浏览器渲染过程
 1. 解析html生产dom 树
 2. 解析css 生产cssom规则树
 3. 将dom树和cssom规则树合并生成渲染成
 4. 节点数开始布局， 计算元素的位置和大小
 5. 将每个节点渲染到页面中

### 渲染阻塞
 当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行，然后继续构建DOM。每次去执行JavaScript脚本都会严重地阻塞DOM树的构建
 - 遵循规则
  - CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
  - JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。


# css 
### 盒子模型
1. 标准盒子模型： width就是content的内容，盒子的宽度是 content + padiing + border
2. IE 盒子模型： width是content + padding + border这是三部分的宽度，盒子的宽度就是width
3. box-sizing : border-box 表示IE盒子模型  ； content-box 标准盒子模型

### 重排和重绘
 - 重排（回流）： 回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。
 - 重绘:由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性

  **回流必定会发生重绘，重绘不一定会引发回流。**

 - 减少重绘和回流
    1. css
        - 使用transform 代替 top
        - 使用visibility 代替display:none   前者只会重绘, 后者回流
        - 使用table布局   因为只要很小的改变, 就会重新布局
        - 尽可能在dom 树末端改变css  回流式不可避免的,但是可以减少
        - 避免设置多次内联样式
    2. js
        - 避免频繁操作样式'
        - 避免频繁操作dom
        - 避免频繁读取会引起回流/ 重绘的属性   如果需要多次使用, 就用变量存起来
        - 对具有复杂动画的元素使用绝对定位  使他脱机文档流

### px , em , rem 
- px:绝对长度， 像素是相当于显示器屏幕分辨率来说的
- em : 相对长度单位，  相对于当前对象内文本字体尺寸
  * em 的值不是固定的， 
  * em 会继承父级元素的字体大小
- rem : 相对于html 跟元素的font-size 

### 画一条0.5px的线
```js 
  setOnePx{
     position: relative;
     
   }
   .setOnePx::after{
     position: absolute;
     content: "";
     background-color: red;
     display: block;
     width: 100%;
     height: 1px;
     transform: scale(1,0.5); 
     top: 50%;
     left: 0;
   }

<div class="setOnePx"></div>
```

### link 标签和 import 标签的区别
1. link 属于html 标签， 而 @impot 是css提供的，
2. 页面被加载时link会被同时加载， 而@import 引用的css 会等到页面加载结束后加载
3. link方式的权重高于@import


### flex
```js

.box{
  flex: 1 0 auto; // 放大不缩小
  flex: 0 1 auto ;  // 不放大缩小
  flext: 1; // flex-grow : 1 ； 将父容器的display:flex, 侧边栏大小固定， 将内容区域flex:1  内容区域自动占满剩余空间
}

flex-grow: 放大比例
flex-shrink : 缩小比例
flex-basis: 定义在分配多余空间之前，项目占据的主轴空间（main size），浏览器根据此属性计算主轴是否有多余空间


```

### BFC
1. 块级格式化上下文 ， 是一个独立的渲染空间， 并有一定布局规则
2. bfc 区域不会与float 和box 重叠
3. 是一个独立的渲染空间， 子元素不会影响到外部元素
4. 计算bfc的高度， 浮动也会参与计算

### 哪些元素会生成BFC
1. 根元素
2. float 不为none 
3. position 为flexd 和 absolute 
4. display为inline-block、table-cell、table-caption，flex，inline-flex的元素
5. overflow不为visible的元素

### 垂直居中的方法
 - https://juejin.cn/post/6844903491891118087#heading-22 
```js
1)margin:auto法
css:
div{ 
  width:400px;
  height:400px;
  position:relative;
  border:1pxsolid#465468;
  }
img{
  position:absolute;
  margin:auto;  // 居中
  top:0;
  left:0;
  right:0;
  bottom:0;
  }
html:
<div><imgsrc="mm.jpg"></div>

2)负值法
css:
div{ 
  width:400px;
  height:400px;
  position:relative;
  border:1pxsolid#465468;
  }
img{
  position:absolute;
  // 居中
  top:50%;
  left:50%;
  transform：translate(-50%, -50%);
  }
html:
<div><imgsrc="mm.jpg"></div>

3)flex
css:
div{ 
  width:400px;
  height:400px;
  display:flex;

  // 居中
  align-items:center;
  justify-content:center;

}
img{
 
}
html:
<div><imgsrc="mm.jpg"></div>
```

### 块元素和行元素
1. 块元素：独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度
2. 行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失效。 

### visibility=hidden,opacity=0，display:none
1. opacity=0 透明度为0  不会改变页面布局, 该区域有click 会被触发
2. visibility=hidden：不会改变页面布局。该区域有click 不会被触发
3. display:none：该元素隐藏起， 会改变页面布局

### position属性比较
1. fixed：固定定位 根据浏览器窗口固定定位，脱标， 不占位置
2. relative： 相对定位 相对于自身定位
3. absolute ： 绝对定位 相对于最近的父元素定位， 脱标， 不占位置
4. sticky： 粘性定位 元素先按照普通文档流定位，然后相对于该元素在流中的flowroot（BFC）和containingblock（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。
5. static 默认定位 

### 清除浮动
1. 给要清除浮动的元素添加样式
  ```js
   .clearfix:before,
        .clearfix:after {
            display: table;
            content: "";    /*不用有内容也可以*/
        }

        .clearfix:after {
            clear: both;
        }

        .clearfix {
            *zoom: 1;
        }

  ```

### Css预处理sassless是什么？
- Sass和less都是css预处理器，是css上的一种抽象层，是一种特殊的语法，最终会编译成css，less是一种动态样式语言，给css赋予了动态，比如：变量，继承，嵌套。Less既可以在客户端运行，在可以在服务端运行（需要借助node

# JavaScript

### 判断数据类型?
- typeof: 判断类型 Number, String, Boolean, Uundefined， Object, Function, Symbol
- instanceof  s instanceof String
- Object.prototype.toString.call()： 能准确的判断出数据类型

- 总结
  1. typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，
  2. 如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。
  3. 准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。


### instanceof 实现原理
- instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型
- instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。

 **instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可**。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

```js
function new_instance_of(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__; // 取左表达式的__proto__值
    while (true) {
    	if (leftVaule === null) {
            return false;	
        }
        if (leftVaule === rightProto) {
            return true;	
        } 
        leftVaule = leftVaule.__proto__ 
    }
}
```

### 0.1+0.2 ! == 0.3 为什么
 - 进制转换 ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致**精度丢失**。
 - 对阶运算 ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（0舍1入），尾数位移时可能会发生数丢失的情况，影响精度。

```js

 解决方案

 1.转为整数（大数）运算。
```

### attr()和prop()的区别
  - attr()函数针对的是该文档节点的attribut，是HTML标签上的特性。
  - prop()函数针对的是DOM元素自身的property，是DOM中的属性。
  - attr()设置的属性值只能是字符串类型。
  - prop()设置的属性值可以为包括数组和对象在内的任意类型。
  - attr()函数主要依赖的是Element对象的getAttribute() 和setAttribute() 两个方法。
  - prop()函数主要依赖的则是JS中原生的对象属性获取和设置方式。

### 事件流
1. 事件冒泡: 当一个元素上的事件被触发, 他是祖先元素也会被触发
2. 事件委托: 给父元素注册事件, 通过事件冒泡触发子元素的事件
3. 阻止事件冒泡和捕获 : e.stopPropagation   ie9   event. cancleBubble = true
4. 阻止默认事件: return false    /  e.preventDefault()

### js是单线程，为啥可以高并发(如何可以请求异步)
  - 消息队列指的是一个先进先出的队列，在这个队列中可以存在各种消息。
  - 事件循环指的是主线程重复从消息队列中获取消息、执行的过程。

### new 做了什么
1. 创建了一个空对象
2. 这个对象指向构造函数的prototype
3. 执行这个构造函数
4. 返回这个对象

```js
  function MyNew(){
    // 1. 创建了一个空对象
    let obj =  {}
    // 2. 这个对象指向构造函数的prototype
    let Con =  [].shift.call(arguments)
    obj.__proto__ =  Con.prototype
    // 3. 执行这个构造函数
    let res = Con.apply(obj, arguments)
    // 4. 返回这个对象
    return res instanceof Object ? res : obj
  }
```

### call bind apply 改变this指向

1. call 改变this指向，参数是x,y, ...
2. applay 改变this指向， 第二个参数是要给**数组** 
3. bind 改变this指向会返回一个新的函数， 这个函数不会马上执行

```js

Function.prototype.myCall = function (context, ...argument) {
  // 将被调用的方法设置为 context 的属性
  // this 即为我们要调用的方法
  context.fn = this
  let res = context.fn(...argument)
  delete context.fn
  return res
}

function add (x,y){
  //通过my_call第一个参数 改变了this的指向， 
  console.log(this); // { a: 1, fn: [Function: add] }
  return this.a + x + y
}
let obj = {a:1}
console.log( add.myCall(obj, 1, 3) );

```


```js

appaly
Function.prototype.myApplay = function (context) {
  context.fn = this
  let arg = [...arguments].splice(1)[0]

  if(!Array.isArray(arg)) {
    throw new Error('apply的第二个参数必须是数组') 
  }  
  let res = context.fn(arg)
  console.log(context.fn,'res');
  delete context.fn
  return res
}

function add (arr){
  console.log(this.a, arr); 

}
let obj = {a:1}
 add.myApplay(obj,[1,2,3])
```


```js
Function.prototype.myBind = function (context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new Error("Type error");
  }
  // 获取参数
  const args = [...arguments].slice(1),
  const fn = this;
  return function Fn() {
    return fn.apply(
      this instanceof Fn ? this : context,
      // 当前的这个 arguments 是指 Fn 的参数
      args.concat(...arguments)
    );
  };
};
```

### 节点类型?判断当前节点类型?
1. 元素节点
2. 属性节点
3. 文本节点
8. 注释节点
9. 文档节点
通过nodeObject.nodeType判断节点类型：其中，nodeObject 为DOM节点（节点对象）。该属性返回以数字表示的节点类型，例如，元素节点返回 1，属性节点返回 2 


### CommonJS、AMD和CMD / es6 模块
1. CommonJS : 服务端的模块化， 同步定义的模块化， 每个模块都是单独的作用域， 模块输出 modules.exports, 模块加载require（）引入模块

2. AMD : 异步模块， requireJS 实现AMD规范， 解决以下两个问题
  - 多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器
  - 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。
  - 语法：requireJS定义了一个函数define，它是全局变量，用来定义模块。

  ```js 
    define(['dependency'],function(){
      var name='Byron';
      function printName(){
        console.log(name);
      }
      return{printName:printName};
      }
    );//加载模块require(['myModule'],function(my){my.printName();}



  ```
3. 总结AMD规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。因为网页在加载JS的时候会停止渲染，因此我们可以通过异步的方式去加载JS,而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。
 

4. commonjs 模块是拷贝， 可以修改值，  es6模块是引用， 只读状态， 不能修改值

### 前端模块规范有三种：CommonJs,AMD和CMD。
  - CommonJs用在服务器端，AMD和CMD用在浏览器环境
  - AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。
  - CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
  - AMD:**提前执行**（异步加载：依赖先执行）+延迟执行
  - CMD:**延迟执行**（运行到需加载，根据顺序执行）

### ES Module 和 CommonJs
   ES Module从语法到原理详解[https://juejin.cn/post/7098192216229117959] 
  1. 区别
    - ES Module 输出的是值的引用，而 CommonJS 输出的是值的拷贝；
    - ES Module 是编译时执行，而 CommonJS 模块是在运行时加载；
    - ES6 Module可以导出多个值，而CommonJs 是单个值导出；
    ES6 Module 静态语法只能写在顶层，而CommonJs 是动态语法可以写在判断里；
    - ES6 Module的 this 是 undefined，而CommonJs 的 this 是当前模块；

    ```js
        // CommonJS模块
    let { stat, exists, readfile } = require('fs');

    // 等同于
    let _fs = require('fs');
    let stat = _fs.stat;
    let exists = _fs.exists;
    let readfile = _fs.readfile;

     > CommonJS模块代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。

     > 这种加载称为**“运行时加载”**，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。
    ```

    ```js
    // ES6模块
    import { stat, exists, readFile } from 'fs';

     > ES6模块代码的实质是从fs模块加载 3 个方法，其他方法不加载。这种加载称为**“编译时加载”或者静态加载**，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。
    ```

### 深拷贝 浅拷贝
1. 浅拷贝
  - Object.assing()  Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。
  ```js
  let a = {a:[1],b:3}
  var c = Object.assign({},a)
  ```
  - Array.prototype.concat()

  ```js
  let arr = [1,2,4,{a:1}]
  let arr1 =  arr.concat()
  console.log(arr , arr1);
  ```
  - Array.prototype.slice()

  ```js
  let arr = [1, 3, {
    username: ' kobe'
  }];
  let arr3 = arr.slice();
  arr3[2].username = 'wade'
  console.log(arr);
  ```

2. 深拷贝
 - JSON.parse(JSON.stringify())

 ```js
  let arr = [1,2,3,{
  name: 'hx'
  }]
  let arr2 =  JSON.parse(JSON.stringify(arr))
  arr2.name =  'bolo'
  console.log(arr, arr2); //[ 1, 2, 3, { name: 'hx' } ] [ 1, 2, 3, { name: 'hx' }, name: 'bolo' ]
 ```
  ```js 
  function deepClone(obj){
    var newObj = obj instanceof Array ? [] : {}
    for(var i in obj){
      var temple =  typeof obj[i] == 'object' ? deepClone(obj[i]) : obj[i]
      newObj[i]= temple
    }
    return newObj
  }
  
  ```

  ```js
  function deepClone(obj, map = new Map()) {
    

    // 判读是不是基础类型
    if (typeof obj !== 'Object') {
      return obj
    }

    if (map.get(obj)){
      return obj
    }
    // 初始化结果
    let result = Array.isArray(obj) || Oject.prototype.toString.call(obj) === '[object,Array]' ? [] : {}
    // 防止循环应用
    map.set(obj, result)
    for (let key in obj) {
      // 调用递归
      result[key] =  deepClone(obj[key], map)
    }
    return result
    
  }
  ```



  ### 实现sleep 
  ```js
  // promise

    function sleep(ms){
      let temple =  new Promise(resolve =>{
        console.log(111);
        setTimeout(resolve, ms)
      })
      return temple
    }

    sleep(3000).then( function(){
      console.log(222);
    })

    // async  
    function sleep1 (ms){
      return new Promise(resolve => {
        setTimeout(resolve, ms)
      })
    }
    async function test(){
      let temple = await sleep1(1000)
      console.log(1);
      return temple
    }

    test()
  ```

### 闭包
- 定义： 一个函数有权访问到另一函数作用域中的变量的函数
- 特点：
  1. 函数嵌套函数
  2. 函数内部可以引用外部的参数和变量
  3. 参数和变量不会被垃圾回收机制回收
- 使用
  1. 读取函数内部的变量；
  2. 这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除。
- 优点
  1. 变量长期驻扎在内存中
  2. 避免全局变量污染
  3. 私有成员的存在
- 缺点：  会造成内存泄漏

### 垃圾回收机制
  1. 标记清楚法 ： 标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。
    - 优点
      - 可以回收循环引用的对象
    - 缺点
      - 不会立即回收垃圾对象

  2. 引用计数法： 设置引用树，判断当前引用计数是否为 0，对象将被垃圾回收机制回收。
    - 优点
      - 发现垃圾立即回收
      - 最大限度减少程序暂停
    - 缺点
      - 无法回收循环引用的对象
      - 时间开销大
  3. V8 的垃圾回收机制
    - 针对新生区采用并行回收
    - 针对老生区采用增量标记与惰性回收。



### 本地存储和cookie 的区别
- cookie 
  1. 4kb左右， 主要用于保存登录信息
  2. 生命周期： 一个会话周期， 可以设置他是时效
  3. 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题

- localStorage
  1. 一般为5M 
  2. 永久存储， 除非被清除
  3. 仅在客户端（即浏览器）中保存，不参与和服务器的通信
- sessionStorage
  1. 一般为5M 
  2. 当前会话有效， 关闭浏览器后被清除
  3. 仅在客户端（即浏览器）中保存，不参与和服务器的通信

 ### 什么是鉴权
 https://juejin.cn/post/7129298214959710244#heading-12
  鉴权(Authentication) 在信息安全领域是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。
  - 校验 session/cookie/token 的合法性和有效性
  1. Session-Cookie 认证步骤解析
      - 客户端： 向服务器发送登录信息用户名/密码来请求登录校验；

      - 服务器： 验证登录的信息，验证通过后自动创建 Session（将 Session 保存在内存中，也可以保存在 Redis 中），然后给这个 Session 生成一个唯一的标识字符串会话身份凭证 session_id(通常称为 sid)，并在响应头 Set-Cookie 中设置这个唯一标识符；

      - 客户端： 收到服务器的响应后会解析响应头，并自动将 sid 保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息；

      - 服务器： 接收客户端请求时会去解析请求头 Cookie 中的 sid，然后根据这个 sid 去找服务端保存的该客户端的 sid，然后判断该请求是否合法；
  2.  Token（令牌）
  Token 是一个令牌，客户端访问服务器时，验证通过后服务端会为其签发一张令牌，之后，客户端就可以携带令牌访问服务器，服务端只需要验证令牌的有效性即可。

    - token认证步骤
      1. 客户端： 输入用户名和密码请求登录校验；
      2. 服务器： 收到请求，去验证用户名与密码；验证成功后，服务端会签发一个 Token 并把这个 Token 发送给客户端；
      3. 客户端： 收到 Token 以后需要把它存储起来，web 端一般会放在 localStorage 或 Cookie 中，移动端原生 APP 一般存储在本地缓存中；
      4. 客户端发送请求： 向服务端请求 API 资源的时候，将 Token 通过 HTTP 请求头 Authorization 字段或者其它方式发送给服务端；
      5. 服务器： 收到请求，然后去验证客户端请求里面带着的 Token ，如果验证成功，就向客户端返回请求的数据，否则拒绝返还（401）；
  
  3. JWT（JSON Web Token）鉴权
      - JWT 由三部分组成： Header 头部、 Payload 负载 和 Signature 签名





### 数组
  1. push()从后面添加元素，返回值为添加完后的数组的长度
  2. arr.pop()从后面删除元素，只能是一个，返回值是删除的元素
  3. arr.shift()从前面删除元素，只能删除一个返回值是删除的元素
  4. arr.unshift()从前面添加元素,返回值是添加完后的数组的长度
  5. arr.splice(i,n)删除从i(索引值)开始之后的那个元素。返回值是删除的元素
  6. arr.concat()连接两个数组**返回值为连接后的新数组**
  7. str.split()将字符串转化为数组
  8. arr.sort()将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的 
  9. arr.reverse()将数组反转,**返回值是反转后的数组**
  10. arr.slice(start,end)切去索引值start到索引值end的数组，不包含end索引的值，**返回值是切出来的数组**
  11. arr.forEach(callback)遍历数组,无return即使有return，也不会返回任何值，并且**会影响原来的数组**
  12. arr.map(callback)映射数组(遍历数组),**有return返回一个新数组**。
  13. arr.filter(callback)过滤数组，**返回一个满足要求的数组**

### .For循环与map循环有什么区别
- For遍历对象自身的和继承可枚举的属性，也就是说会包括哪些原型链上的属性
- Map方法不会对空数组进行检测，map会返回一个新数组，不会对原数组产生影响    map 不能跳出循环  只能通过 throw 抛出异常 



### for.. in / for...of
https://www.cnblogs.com/rogerwu/p/10738776.html

for...in 循环主要是为了**遍历对象**而生，不适用于遍历数组

for...of 循环可以用来**遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象**

### 跳出循环
forEach 循环**无法**中途跳出，break 命令或 return 命令都不能奏效

for...of 循环**可以**与break、continue 和 return 配合使用，跳出循环
### 节流(throttle)和防抖（debounce）
- 节流： 对于短时间内连续触发的事件（上面的场景：连续请求同一个接口），节流的含义就是在某个时间期限内每隔（预定300毫秒）执行一次
- 函数节流是声明一个变量当标志位，记录当前代码是否在执行，如果正在执行，取消这次方法执行，直接return，如果空闲，正常触发方法执行
```js 
function throttle(fun, delay) {
      let last, deferTimer
      return function (args) {
          let that = this
          let _args = arguments
          let now = +new Date()
          if (last && now < last + delay) {
              clearTimeout(deferTimer)
              deferTimer = setTimeout(function () {
                  last = now
                  fun.apply(that, _args)
              }, delay)
          }else {
              last = now
              fun.apply(that,_args)
          }
      }
  }
```

- 防抖： 对于短时间内**连续**触发的事件，防抖的含义就是让某个时间期限内（约定200毫秒），事情处理函数只执行一次
- 函数防抖是需要一个延时器来辅助实现，延迟执行需要执行的代码，如果方法多次触发，把上次记录的延迟执行代码用cleartimeout清除掉，重新开始，如果计时完毕，没有方法来访问触发，则执行代码、

```js 
function debounce(fun, delay) {
    return function (args) {
        let that = this
        let _args = args
        clearTimeout(fun.id)
        fun.id = setTimeout(function () {
            fun.call(that, _args)
        }, delay)
    }
}
```



### 跨域
  - 跨域问题来源于，js的同源策略， 端口， 协议， 域名， 有一个不同就会跨域
  - 解决方法
    1. jsonp  
      - JSONP 是一种非正式传输协议，允许用户传递一个callback给服务端，然后服务端返回数据时会将这个callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。当GET请求从后台页面返回时，可以返回一段JavaScript代码，这段代码会自动执行，可以用来负责调用后台页面中的一个callback函数。
    2. 设置cors 请求头
    3. Nginx设置反向代理 
    4. postmassage


### jsonp 原理
- 通过动态创建**script**标签， 在请求一个带参数网上实现跨越通信

```html 
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

  <button onclick="send( 'hx')"> 模拟jsonp</button>
  
</body>
<script>
  function jsonp ({url, params, key ,callback}){
    var fnName = 'callback'+Date.now().toString()
    window[fnName] = callback
    var scriptEle = document.createElement('script')
    scriptEle.src = url + parseParams(params) + `&${key}=${fnName}`
    document.body.appendChild(scriptEle)
    setTimeout(() => {
      document.body.removeChild(scriptEle)
    }, 0);
  }
  function parseParams(params){
    var str = '?'
    Object.keys(params).forEach(k=>{
      str = str + k + '=' + params[k] + '&'
    })
    console.log('str',str.slice(0,str.length-1))
    return str.slice(0,str.length-1)
  }
  

</script>

<script>

  function send( name){
    jsonp({
      url: "http://localhost:9999/hello",
      params:{
        name, 
        age: 1
      }, 
      key: 'callback', // 和服务端约定好回调的字段
      callback: function(res){
        console.log(res,'res');
      }
    })
  }
</script>
</html>
```

### 什么是虚拟DOM 
- 用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把所记录的差异应用到所构建的真正的DOM树上，视图就更新了。VirtualDOM本质上就是在JS和DOM之间做了一个缓存。

### 事件监听
1. addEventListener()方法，用于向指定元素添加事件句柄，它可以更简单的控制事件
2. element.addEventListener(event,function,useCapture);
  - 第一个参数是事件的类型(如"click"或"mousedown").
  - 第二还是捕获。该参个参数是事件触发后调用的函数。
  - 第三个参数是个布尔值用于描述事件是冒泡数是可选的。事件传递有两种方式，
  - 冒泡和捕获事件传递定义了元素事件触发的顺序，如果你将P元素插入到div元素中，用户点击P元素，在冒泡中，内部元素先被触发，然后再触发外部元素，捕获中，外部元素先被触发，在触发内部元素。

### 原型链
- 每个构造函数都自带一个prototype属性， 指向原型对象
- 每个实例上都有个__proto__ 属性， 指向原型对象
- 原型对象有一个construction， 指向构造函数

### 原型链的核心
- 依赖对象的__proto__ 的指向，当自身不存在的属性时， 就一层层的往上找找到对象的构造函数， 知道Object时， 就没有__proto__ 最后返回null

### 箭头函数特性
1. 箭头函数没有this，需要通过查找作用域来确定this的值， this绑定的就是最近一层非箭头函数的this
2. 箭头函数没有自己的arguments对象， 但是可以访问到外层函数的arguments对象
3. 不能用new关键字调用


### 异步加载js的方法
1. defer: 可将defer属性加入到 **script**标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。

2. async: HTML5属性仅适用于外部脚本，并且如果在IE中，同时存在defer和async，那么defer的优先级比较高，脚本将在页面完成时执行。创建script标签，插入到DOM中

### Ajax解决浏览器缓存问题
1. 在ajax发送请求前加上anyAjaxObj.setRequestHeader("If-Modified-Since","0")。
2. 在ajax发送请求前加上anyAjaxObj.setRequestHeader("Cache-Control","no-cache")。
3. 在URL后面加上一个随机数："fresh="+Math.random()。
4. 在URL后面加上时间搓："nowtime="+newDate().getTime()。



### 实现一个ajax
  - AJAX创建异步对象XMLHttpRequest操作XMLHttpRequest对象
  - 设置请求参数（请求方式，请求页面的相对路径，是否异步）
  - 设置回调函数，一个处理服务器响应的函数，使用onreadystatechange，类似函数指针
  - 获取异步对象的readyState属性：该属性存有服务器响应的状态信息。每当readyState改变时，onreadystatechange函数就会被执行。
  - 判断响应报文的状态，若为200说明服务器正常运行并返回响应数据。
  - 读取响应数据，可以通过responseText属性来取回由服务器返回的数据。

```js 
  var xhr = new XMLHttpRequest()
  xhr.open('get', 'aabb.php', true)
  xhr.send(null)
  xhr.onreadystatechange =  function() {
    if(xhr.readyState == 4){
      if(xhr.status == 200){
        console.log(xhr.responseText);
      }
    }
}
```

### 如何确保ajax或连接不走缓存路径
```js
  在Ajax中使用Get请求数据不会有页面缓存的问题，而使用POST请求可是有时候页面会缓存我们提交的信息，导致我们发送的异步请求不能正确的返回我们想要的数据

  $.post(url,data ,ranNum:Math.random()} ,function(data){}）

  ranNum : 这个是防止缓存的核心，每次发起请求都会用Math.random()方法生成一个随机的数字，这样子就会刷新url缓存

```


### 如何实现ajax请求，假如我有多个请求，我需要让这些ajax请求按照某种顺序一次执行，有什么办法呢？如何处理ajax跨域


# ES6 
### promise
  1. 用于解决异步编程的方案
  2. 有三种状态： pending， resolved , rejected ,状态一旦创建就不可改变， 状态不可逆转



# vue 
### Vue的理解
 - Vue是一个构建数据驱动的渐进式框架， 通过api 实现响应数据绑定视图更新
 - 数据驱动
 - 组件化

 ### 为什么说Vue是一个“渐进式”框架
 1. 声明式渲染 、 组件化应用 、客户端路由（router）、 集中式状态管理(vuex) 、项目构建
 2. 渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现；也可以整个用它全家桶开发；还可以用它的视图，搭配你自己设计的整个下层用。它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事

 ### Vue 父组件如何监听子组件的生命周期
 #### 通过 $emit 实现
 ```js
  这里以 mounted 为例，在父组件 Parent 和子组件 Child 中，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：

  // Parent.vue
  <Child @mounted="doSomething"/>
      
  // Child.vue
  mounted() {
    this.$emit("mounted");
  }
  以上方法虽然可行，但每次都需要手动写一次 $emit 触发父组件的事件
  更简单的方式可以在父组件引用子组件时通过 @hook 来监听生命周期

 ```
 #### 通过 @hook 实现
 ```js
  还是父组件 Parent 和子组件 Child，@hook 的写法如下：

  //  Parent.vue
  <Child @hook:mounted="doSomething" ></Child>

  doSomething() {
    console.log('父组件监听到 mounted 钩子函数 ...');
  },
      
  //  Child.vue
  mounted(){
    console.log('子组件触发 mounted 钩子函数 ...');
  },    
      
  // 以上输出顺序为：
  // 子组件触发 mounted 钩子函数 ...
  // 父组件监听到 mounted 钩子函数 ...     
  当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听

 ```

 ### vue style scoped 属性作用是啥，如何是样式仅在当前模块生效
 - 作用：实现组件的私有化，不对全局造成样式污染，表示当前 style 属性只属于当前模块
 - 原理：打包之后，编译成特定样式，data-v-[hash]，即 CSS 带属性选择器
 ### watch 和 computed 
 - watch ： 监听已经在data中定义的变量， 当变量变化是， 会触发watch中的方、法
 - computed ： 用来声明式的描述一个值依赖了其他的值， 当所有依赖的值或者变量改变时， 计算属性也会跟着改变

 ### v-model是什么？有什么用呢？
 - 则语法糖，相当于v-bind:value="xxx"和@input，意思是绑定了一个value属性的值，子组件可对value属性监听，通过$emit('input',xxx)的方式给父组件通讯。自己实现v-model方式的组件也是这样的思路

 ### axios是什么， 怎么使用 ？ 怎么解决跨域
 1. axios 是一个总异步请求，类似ajax
 2. 安装npm i install axios --save ,请求中包括get, push ， put, patch , delete 等五种请求方式
 3.解决跨域可以在请求头中添加Access-Control-Allow-Origin， 也可以在index 页面中添加proxyTable 配置解决跨域问题

 ### vue在created和mounted这两个生命周期中请求数据有什么区别呢？
 - 一般在created（或beforeRouter）里面就可以，如果涉及到需要页面加载完成之后的话就用mounted。
 - 在created的时候，视图中的html并没有渲染出来，所以此时如果直接去操作html的dom节点，一定找不到相关的元素而在mounted中，由于此时html已经渲染出来了，所以可以直接操作dom节点，（此时document.getelementById即可生效了）

 ### vuex是什么
 - vuex 是Vue的状态管理工具。 通过创建一个集中的数据存储， 方便程序中的所有组件进行访问
 - 有五个属性  state / getter/ mutations/ acitons/ modules
  1. state :就是数据源 存放地 用this.$store.state.xxx调用
  2. getters : 相当于store的计算属性，主要是对state中数据的过滤，用this.$store.getters.xxx调用
  3. 处理数据逻辑的方法全部放在mutations中，当触发事件想改变state数据的时候使用mutations，用this.$store.commit调用，给这个方法添加一个参数，就是mutation的载荷（payload）
  4. Actions异步操作数据，但是是通过mutation来操作用this.$store.dispatch来触发，actions也支持载荷

### vuex的store是如何挂载注入到组件中呢？
  vuex是利用vue的mixin混入机制，在beforeCreate钩子前混入vuexInit方法，vuexInit方法实现了store注入vue组件实例，并注册了vuex store的引用属性$store。store注入过程如下图所示：
### vuex的state和getters是如何映射到各个组件实例中响应式更新状态呢？
  Vuex的state状态是响应式，是借助vue的data是响应式，将state存入vue实例组件的data中；Vuex的getters则是借助vue的计算属性computed实现数据实时监听。
### Vue路由的跳转方式

- vue路由跳转分为  声明式和编程式
- js方式进行跳转的叫编程式导航this.$router.push（） 
- router-link： 声明式， router-view路由出口， 路由模板显示的位置

### Vue如何进行动态路由设置
- 动态路由也可以叫路由传参
- 动态路由有query和prams两种方式传参
- query用path引入， params用name引入， 
- query  => this.$route.query.name 接收参数
- params  => this.$route.params.name 接收参数

### Vue Router提供了三种类型的导航守卫：

  1. 全局守卫：在整个应用程序中，所有的路由变化都会触发这些守卫。可以通过Vue Router实例的beforeEach、beforeResolve和afterEach方法来注册全局守卫。
  2. 路由独享守卫：在某个路由上，只有该路由变化时才会触发这些守卫。可以在路由配置对象中通过beforeEnter属性来注册路由独享守卫。
  3. 组件内守卫：在某个路由对应的组件中，可以通过Vue组件生命周期钩子函数来监听路由的变化，实现一些组件内部的路由控制逻辑。


### vue 中的指令
 - v-for：循环数组，对象，字符串，数字
 - v-on：绑定事件监听
 - v-bind：动态绑定一个或者多个属性
 - v-model：表单控件或者组件上创建双向绑定 
 - v-ifv-elsev-else-if条件渲染
 - v-show根据表达式真假，切换元素的display
 - v-html更新元素的innerhtmlv-text更新元素的textcontent
 - v-pre跳过这个元素和子元素的编译过程
 - v-clock这个指令保持在元素上知道关联实例结束编译
 - v-once只渲染一次

 ### vue 中的keep-alive
 - keep-alive 是vue的内置组件，当他动态包裹组件时， 会缓存不活动的组件实例，他自身不会渲染成一个dom元素也不会出现在父组件链中
 - 作用： 在组件切换过程中将状态保留在内存中， 防止重复渲染DOM，

 ### vue 3.0 如何变得更快
 - diff方法优化
  * vue2.0 中虚拟dom 是进行全量对比的
 - vue3.0 新增静态标记， 
  * Vue2.x:无论元素是否参与更新，每次都会重新创建 
  * vue3.0 :对不参参与更新的元素， 只会被创建一次， 之后每次渲染时被不同的复用
 - cacheHandles事件侦听器缓存
  * 默认情况下onClick会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。

 ### 页面刷新后vuex的state数据丢失怎么解决
  - store里的数据是保存在运行内存中的,当页面刷新时，页面会重新加载vue实例，store里面的数据就会被重新赋值初始化。
  - 将 vuex 中的数据直接保存到浏览器缓存中（sessionStorage、localStorage、cookie） 
  - 在页面刷新的时候再次请求远程数据，使之动态更新 vuex 数据
  - 在父页面向后台请求远程数据，并且在页面刷新前将 vuex 的数据先保存至sessionStorage（以防请求数据量过大页面加载时拿不到返回的数据）

 ### vue组件里写的原生addEventListeners监听事件，要手动去销毁吗？为什么？
  - 要在 beforeDestroy 手动销毁，否则如果在 mounted 中使用 addEventListeners，可能会多次重复注册导致内存泄漏。

 ### vue 传值方式
  https://juejin.cn/post/7110223595359436813#heading-6
  1. props : 父传子
  2. ref
  3. vuex
  4. v-on $emit : 子组件通过派发事件的方式给父组件数据，或者触发父组件更新等操作
  5. provied/ inject 依赖注入
    - provide：可以让我们指定想要提供给后代组件的数据或方法
    - inject: 在任何后代组件中接收想要添加在这个组件上的数据或方法，不管组件嵌套多深都可以直接拿来用
    - **!!!provide 和 inject 传递的数据不是响应式的，也就是说用 inject 接收来数据后，provide 里的数据改变了，后代组件中的数据不会改变，除非传入的就是一个可监听的对象 所以建议还是传递一些常量或者方法**
  6. $childer $parent
  7. eventbus

 ### 父子组件生命周期执行顺序
  - 加载渲染过程
    - 父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
  - 更新过程
    - 父beforeUpdate->子beforeUpdate->子updated->父updated
  - 销毁过程
    - 父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

  # vue是如何实现响应式的(MVVM) 
  vue通过**数据劫持**和**发布-订阅模式**实现数据的响应式，通过Object.defineProperty来劫持数据， 把data中的数据转换成getter和setter，在数据发生变化时发布消息给订阅者，订阅者收到消息进行视图的更新

  ### MVVM 的双向绑定，就必须要实现以下几点：

  https://github.com/DMQ/mvvm/blob/master/img/2.png
  1. vue: 把data中的成员注入到vue 实例中， 并把data中的成员转换成getter/setter
    - 功能
      - 记录传入的选项， 设置$data/$el
      - 把data中的数据注入到vue实例中
      - 负责调用observer数据响应处理（数据劫持）
      - 负责调用compiler编译指令、差值表达式
  2. observer
      - 数据劫持
        - 负责把data中成员转换成getter和setter
        - 负责把多层属性转换成 getter/setter
        - 如果给属性赋值为新对象，把新对象的成员设置为 getter/setter
      - 添加dep和watcher的依赖关系
      - 数据变化发送通知
  3. compiler
    - 负责编译模板，解析指令、差值表达式
    - 负责页面的首次渲染过程
    - 当数据发生变化，重新渲染
  4. Dep
    - 收集依赖 ，添加订阅者（watcher）
    - 通知所有订阅者
  5. watcher
    - 自身实例化的时候往dep对象中添加自己
    - 当数据变化dep通知所有的 Watcher 实例更新视图


  ### Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过bject.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：
    1. 需要 observe 的数据对象进行递归遍历，包括子属性对象的属性， 都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化
    2. compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
    3. Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:
      ①在自身实例化时往属性订阅器(dep)里面添加自己 
      ②自身必须有一个 update()方法
      ③待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功成身退。

  ### nextTick 原理
  - 在DOM更新完毕之后执行一个回调
  - vue是数据的变化到 DOM 的重新渲染是一个异步过程用异步队列的方式来控制DOM更新和nextTick回调先后执行
  - microtask（微任务）因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕

  # vue3
  - ref
    1. 响应**基本类型**
  - refs
  - toRefs
  - reactive
    1. 响应仅对**对象类型**有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。
  

 # react
 ### react生命周期
 - componentWillMount组件渲染之前调用
 - componentDidMount在第一次渲染之后调用
 - componentWillReceiveProps在组件接收到一个新的props时调用
 - shouldComponentUpdate判断组件是否更新html
 - componentWillupdate组件即将更新html时调用
 - componentDidupdate在组件完成更新后立即调用componentWillUnmount在组件移除之前调用

 ### React 性能优化是哪个函数
 - shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘dom， 因为dom的描述非常消耗性能

 ### 虚拟dom如何提高性能
 1. 虚拟dom，相当于在js 和真实dom中间加了一个缓存， 利用dom diff 算法避免没有必要的操作， 从而提高性能
  - 用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档当中；
  - 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异；
  1. 性能提升
    直接操作DOM是有限制的，一个真实元素上有很多属性，如果直接对其进行操作，同时会对很多额外的属性内容进行了操作，这是没有必要的。如果将这些操作转移到JS对象上，就会简单很多。另外，操作DOM的代价是比较昂贵的，频繁的操作DOM容易引起页面的重绘和回流。如果通过抽象VNode进行中间处理，可以有效减少直接操作DOM次数，从而减少页面的重绘和回流。
  2. 方便跨平台实现
    同一VNode节点可以渲染成不同平台上对应的内容，比如：渲染在浏览器是DOM元素节点，渲染在Native（iOS、Android）变为对应的控件。Vue 3 中允许开发者基于VNode实现自定义渲染器（renderer），以便于针对不同平台进行渲染。

#### diff 算法

- 概念：
  diff算法是一种对比算法，通过对比旧的虚拟DOM和新的虚拟DOM，得出是哪个虚拟节点发生了改变，找出这个虚拟节点并只更新这个虚拟节点所对应的真实节点，而不用更新其他未发生改变的节点，实现精准地更新真实DOM，进而提高效率。
- 对比方式：
  diff算法的整体策略是：深度优先，同层比较。比较只会在同层级进行, 不会跨层级比较；比较的过程中，循环从两边向中间收拢。

  1. 首先判断两个节点的tag是否相同，不同则删除该节点重新创建节点进行替换。tag相同时，先替换属性，然后对比子元素，分为以下几种情况：
      - 新旧节点都有子元素时，采用双指针方式进行对比。新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode节点再分情况操作。
      - 新节点有子元素，旧节点没有子元素，则将子元素虚拟节点转化成真实节点插入即可。
      - 新节点没有子元素，旧节点有子元素，则清空子元素，并设置为新节点的文本内容。
      - 新旧节点都没有子元素时，即都为文本节点，则直接对比文本内容，不同则更新。


 ### diff算法
 1. 把树形结构按照层级分解， 只比较同级元素
 2. 给列表结构的每个单元添加唯一的key属性，方便比较。
 3. React只会匹配相同class的component（这里面的class指的是组件的名字）
 4. 合并操作，调用component的setState方法的时候,React将其标记为dirty.到每一个事件循环结束,React检查所有标记dirty的component重新绘制.
 5. 选择性子树渲染。开发人员可以重写shouldComponentUpdate提高diff的性能。


 ### diff 算法

1. 概念：
  diff算法是一种对比算法，通过对比旧的虚拟DOM和新的虚拟DOM，得出是哪个虚拟节点发生了改变，找出这个虚拟节点并只更新这个虚拟节点所对应的真实节点，而不用更新其他未发生改变的节点，实现精准地更新真实DOM，进而提高效率。
2. 对比方式：
  diff算法的整体策略是：**深度优先，同层比较**。比较只会在同层级进行, 不会跨层级比较；比较的过程中，循环从两边向中间收拢。


  首先判断两个节点的tag是否相同，不同则删除该节点重新创建节点进行替换。
3. tag相同时，先替换属性，然后对比子元素，分为以下几种情况：

  - 新旧节点都有子元素时，采用双指针方式进行对比。新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode节点再分情况操作。
  - 新节点有子元素，旧节点没有子元素，则将子元素虚拟节点转化成真实节点插入即可。
  - 新节点没有子元素，旧节点有子元素，则清空子元素，并设置为新节点的文本内容。
  - 新旧节点都没有子元素时，即都为文本节点，则直接对比文本内容，不同则更新。


 ### react性能优化方案
 1. 重新shouldComponentUpdate 避免不必要的dom操作 
 2. 使用key 来帮助react 识别列表中所有子组件的最小变化

 ### 类组件(Classcomponent)和函数式组件(Functionalcomponent)之间有何不同
 1. 类组件不允许你使用更多额外的工能， 如组件自身的状态和声明周期钩子也能使用组件直接访问store 并维持状态
 2. 当组件仅是接收props，并将组件自身渲染到页面时，该组件就是一个'无状态组件(statelesscomponent)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumbcomponents)或展示组件

### (组件的)状态(state)和属性(props)之间有何不同？
1. state 是一种数据结构， 用于组件挂载是所需要数据的默认值， State可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。
2. props是组件的配置， props由父组件传递给子组件， 并且子组件而且， props 是不可变的， 组件不能改变自身的props, 但是可以把其子组件的props放在一起(统一管理)。Props也不仅仅是数据--回调函数也可以通过props传递

### 在React组件的何处发起Ajax请求？
- 在React组件中，应该在componentDidMount中发起网络请求。这个方法会在组件第一次“挂载”(被添加到DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前Ajax请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用setState，这将不起作用。在componentDidMount中发起网络请求将保证这有一个组件可以更新了。

### 在React中，refs的作用是什么？
- Refs可以用于获取一个DOM节点或者React组件的引用。何时使用refs的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方DOM库集成。你应该避免使用String类型的Refs和内联的ref回调。Refs回调是React所推荐的。

### (在构造函数中)调用super(props)的目的是什么？
- 在super()被调用之前，子类是不能使用this的，在ES2015中，子类必须在constructor中调用super()。传递props给super()的原因则是便于(在子类中)能在constructor访问this.props。

## react 和 vue 的区别


# WebSocket

###  WebSocket是html5规范中的一个部分，它借鉴了socket这种思想，为web应用程序客户端和服务端之间（注意是客户端服务端）提供了一种全双工通信机制

  1. 建立在 TCP 协议之上，服务器端的实现比较容易；
  2. 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器；
  3. 数据格式比较轻量，性能开销小，通信高效；
  4. 可以发送文本，也可以发送二进制数据；
  5. 没有同源限制，客户端可以与任意服务器通信；
  6. 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL，形如：ws://example.com:80/some/path。
# HTTP
### http发展史
- HTTP/0.9
  只有 GET 请求获取 HTML 文档，并且在响应请求之后立即关闭连接。

  HTTP/0.9 虽然很简单，但它作为一个“原型”，充分验证了 Web 服务的可行性，而“简单”也正是它的优点，蕴含了进化和扩展的可能性，因为： “把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多。

- HTTP/1.0
  因为多媒体技术( JPEG、 MP3 等相继发明)的发展,网名推动 HTTP 快速发展，并在 1996 年正式发布了 HTTP/1.0 。

  1. 增加了 HEAD、POST 等新方法；
  2. 增加了响应状态码，标记可能的错误原因；
  3. 引入了协议版本号概念；
  4. 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；
  5. 传输的数据不再仅限于文本。
  6. 但 HTTP/1.0 并不是一个“标准”，只是记录已有实践和模式的一份参考文档，不具有实际的约束力，相当于 一个“备忘录”。

- HTTP/1.1
  浏览器大战之后，HTTP 协议成为一个“正式的标准”，而不是一份可有可无的“参考文档”,少了很多学术气息，更加接地气了。

  - HTTP/1.1 主要的变更点有：
    1. 增加了 PUT、 DELETE 等方法
    2. 允许数据分块（chunked）,支持大文件的上传
    3. 强制要求 HOST 头，让互联网主机托管成为了可能
    4. 增加了缓存管理
    5. 明确了连接管理，**支持长连接**(connection:keep-alive)
    6. 引入了客户端 Cookie、安全机制
    7. 这次标准的确定，成为了我们日常使用的 HTTP。

  - 主要问题
    HTTP/1.1对带宽的利用率却并不理想

  - TCP 的慢启动
    一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。

  - 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。
    在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。这样就会阻塞关键资源的下载
  
  - 队头阻塞的问题。
    HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。

  - HTTPS
    HTTPS 是为了解决 HTTP 安全问题的一个新协议，由“HTTP over HTTP ”变成了“ HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上， 收发报文不再使用 Socket API，而是调用专门的安全接口。

- HTTP/2
  - HTTP 成为标准后，一家独大了十多年。直至 Chrome 开发出自己的浏览器，推出新的 SPDY协议 并应用在自己的浏览器上。这倒逼 HTTP 以 SPDY协议 为基础推出 HTTP 2 。

    在性能改善上做出了很多努力：

    1. 变成二进制协议。
    2. 废弃 1.1 中的管道，**引入了二进制分帧层,实现了多路复用**,解决了队头堵塞问题
       HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。

    3. 使用头部压缩算法，减少数据传输量（开发了“HPACK”算法，在客户端和服务器建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的⾼压缩率。 ）

    4. 设置请求的优先级

    增强了安全性（为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密 的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字⺟“c”的意思是“clear text”）

- HTTP/3
  HTTP/2 只解决了应用层的队头堵塞问题，但 TCP 协议仍然会有因为包丢失而造成的堵塞。随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。

http0.9：只具备最基础的HTTP连接模型，在非常短的一段时间内存在，后面被快速完善。
http1.0： 1.0版本中每个TCP连接只能发送一个请求，数据发送完毕连接就关闭，如果还要请求其他资源，就必须重新建立TCP连接。（TCP为了保证正确性和可靠性需要客户端和服务器三次握手和四次挥手，因此建立连接成本很高）
http1.1：

长连接：新增Connection字段，默认为keep-alive，保持连接不断开，即 TCP 连接默认不关闭，可以被多个请求复用；
管道化：在同一个TCP连接中，客户端可以发送多个请求，但响应的顺序还是按照请求的顺序返回，在服务端只有处理完一个回应，才会进行下一个回应；
host字段：Host字段用来指定服务器的域名，这样就可以将多种请求发往同一台服务器上的不同网站，提高了机器的复用，这个也是重要的优化；
HTTP/2：

二进制格式：1.x是文本协议，然而2.0是以二进制帧为基本单位，可以说是一个二进制协议，将所有传输的信息分割为消息和帧，并采用二进制格式的编码，一帧中包含数据和标识符，使得网络传输变得高效而灵活；
多路复用：2.0版本的多路复用多个请求共用一个连接，多个请求可以同时在一个TCP连接上并发，主要借助于二进制帧中的标识进行区分实现链路的复用；
头部压缩：2.0版本使用使用HPACK算法对头部header数据进行压缩，从而减少请求的大小提高效率，这个非常好理解，之前每次发送都要带相同的header，显得很冗余，2.0版本对头部信息进行增量更新有效减少了头部数据的传输；
服务端推送：在2.0版本允许服务器主动向客户端发送资源，这样在客户端可以起到加速的作用；


### http 和HTTPs 的区别
- http : 超文本传输协议 信息是明文传输， https是具有安全性的ssl解密传输协议
- http 和 https 连接方式不同， 端口不同， http 80 https： 443
- http链接很简单， 是无状态的， https协议是有ssl + http 协议构建的可进行加密传输

### 常见的状态码
1. 200 请求成功
2. 301 永久重定向 客户端请求网页已永久移动到新的位置， 
3. 302 临时重定向
4. 304 客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况
5. 403 请求资源的访问被服务器拒绝了
6. 404 客户端请求的资源没有找到
7. 500 服务端遇到未知错误
8. 503 服务器由于临时的服务器过载或者维护

# 优化

### 缩短请求耗时
  1. 优化打包资源
     ```h
      webpack
      webpack-bundle-analyzer可视化分析工具
      常用方法：
      减小体积：减少非必要的import;压缩JS代码;配置服务器gzip等;使用WebP图片;
      按需加载：可根据“路由”、“是否可见”按需加载JS代码，减少初次加载JS体积。比如可以使用import()进行代码分割，按需加载;
      分开打包：利用浏览器缓存机制，依据模块更新频率分层打包。
      其他方法：雪碧图：每个HTTP/1.1请求都是独立的TCP连接，最大6个并发，所以合并图片资源可以优化加载速度。HTTP/2已经不需要这么做了
     ```
  2. CDN加速 : 通过分布式的边缘网络节点，缩短资源到终端用户的访问延迟
    - 加速图片、视频等大体积文件
  3. 浏览器缓存 ： 避免重复传输相同的数据，节省网络带宽，加速资源获取。
    ```h
      强缓存：
        Expires：HTTP/1.0
        Cache-Control：HTTP/1.1
      协商缓存：
        ETag + If-None-Match
        Last-Modified + If-Modified-Since

    ```
  4. Web Socket: 解决HTTP协议无法实时通信的问题。
  5. 服务器端渲染(SSR): 第一次访问时，服务器端直接返回渲染好的页面

### 减少重排重绘
  - 减少渲染量
    1. 虚拟列表， 
    2. 惰性加载
    3. 按需加载
  - 减少渲染次数
    1. 防抖与节流

### 如何对网站的文件和资源进行优化？
 1. 减少http 请求
 2. 文件压缩
 3. 使用缓存
 4. gizp压缩
 
### 大量图片加载很慢你有什么办法进行优化
1. 图片懒加载， 在图片未进入可是区域加载一个滚动条 ， 判断图片位置与浏览器顶端和页面的距离
2. 图片预加载： 将当前展示图片的前一张和后一张优先下载
3. 使用css sprite， 、svg


### 预加载和懒加载
- 预加载 ： 在页面加载完成之前， 提前将所需要的资源下载， 之后从缓存中调用
- 懒加载： 懒加载是延迟加载，按照一定的条件或者需求等到满足条件的时候再加载对应的资源
- 两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。



# webpack 
### webpack打包原理
- webpack 把项目当做一个整体， 通过给定一个主文件， webpack将从这个主文件， 开始叨叨项目中所有依赖的文件， 使用loaders 处理 ，最后打包成一个或者多个浏览器可以识别的js  文件

### webpack构建流程
 webpack是一个串行的过程， 从启动到结束会 依次执行以下顺序
 - 初始化参数： 从配置文件和shell语句中读取和合并参数，得出最终参数
 - 开始编译： 用上一步得到的参数complier对象，加载所有配置的插件， 执行对象的run方法开始执行编译
 - 确定入口： 根据配置中的entry找出所有入口文件
 - 模块化编译： 从入口文件出发， 调用所有配置的loader对模块进行编译， 在找出改模块的依赖模块， 再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
 - 完成模块编译： 在经过第四步使用loader翻译完所有模块后， 得到每个模块被翻译后的最终内容以及他们之间的依赖关系
 - 输出资源： 根据入口和模块之间的依赖关系， 组装成一个个包含多个模块的chunk 再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
 - 输出完成： 确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

### loader 工作流程
- 

### webpack中的loaders与plugin的区别
- loaders : 文件加载器， 能够加载资源文件， 并进行文件的处理 ，例如： 编译， 压缩 最终一起打包到指定的文件中 
- plugin ：插件， 相当于扩展webpack的功能 ， 可以实现loader不能完成的复杂功能
- 在运行时机上
  - loader 运行在打包文件之前；
  - plugin则是在整个编译周期都起作用。
- 在配置上
  - loader在module.rules中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性；
  - plugin在 plugins中单独配置，类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。

### webpack 如何提高性能的
- 压缩代码： 删除多余代码， 注释， 简化代码  可用 webpack的 *UglifyJsPlugin* 和 *ParallelUglifyPlugin* 来压缩js 文件 
- 利用cdn加速， 在构建过程中，将引用的静态资源路劲修改为cdn 对应的路径， 可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径
- 提取公共diamante

### webpack 如何提高构建速度
- 多入口情况下，使用CommonsChunkPlugin来提取公共代码
- 通过externals配置来提取常用库
- 利用Dllplugin 和DllReferencePlugin 预编译资源模块，  通过DllPlugin来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过DllReferencePlugin将预编译的模块加载进来
- 使用Happypack 实现多线程加速编译
- 使用Tree-shaking和Scope Hoisting来剔除多余代码 
- 拆包
- 使用HtmlWebpackPlugin插件来生成 HTML 的模板时候，通过配置属性minify进行 html 优化。

### vite和webpack区别
  1. 构建方式不同：**Vite 利用 ES Modules 的特性进行构建**，每个文件都是一个独立的模块，开发过程中只需要编译修改的文件，不需要每次都编译整个项目；而 Webpack **采用静态分析的方式进行构建，需要分析整个项目中的依赖关系，**每次修改后需要重新编译整个项目**。
  2. 开发体验不同：Vite 支持快速的热更新和即时预览，开发者可以在修改代码的同时，立即在浏览器中查看到最新效果；而 Webpack 需要重新编译后才能查看最新效果。
  3. 对 Vue 的支持：Vite 是 Vue.js 官方推荐的开发工具，内置了对 Vue 单文件组件的支持，可以直接在浏览器中运行 Vue 组件；而 Webpack 需要通过插件等方式进行支持。
  4. 总体来说，Vite 更适合于轻量级的应用，对于 Vue 单文件组件的支持更加完善，而 Webpack 则更适合于复杂的应用，可以通过插件等方式进行更加灵活的配置
  5. vite支持热重载


### 页面打开比较慢 
- 服务端问题
  - 接口
- 前端问题
  - 缓存问题 ： dns 缓存， 
  - 体积问题
  - 代码问题： 内存泄漏等

### 地址输入到展示
- dns解析ip 地址
- tpc 三次握手 
- 建立通信 ， 请求页面
- html  css  js 解析dom 树 

* 优化
  - nds慢  网络慢  代理了
  - dom节点多

### js 单线程  如何进行异步
- eventloop 过程
- settimeout 
- 异步队列  
- 宏任务、 微任务  
宏任务中有微任务  ？ 

### 内存泄漏
- settiomeout  没有清除定时器
- 闭包
- 全局
 —— 排查  ： 监控排查 ， codereview 

### 链表如何删除某个值

### 排序
- 冒泡
- 快排

### 组件封装 思想
- 输入， 输出 事件绑定 回调
- 模板， 样式， 逻辑 
- 接受参数，  
- 扩展性 插槽， 对内网的暴露

# Babel

### abel 的原理是什么?
  babel 的转译过程也分为三个阶段，这三步具体是：
  1. 解析 Parse: 将代码解析生成抽象语法树（AST），即词法分析与语法分析的过程；
  2. 转换 Transform: 对于 AST 进行变换一系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添加、更新及移除等操作；
  3. 生成 Generate: 将变换后的 AST 再转换为 JS 代码, 使用到的模块是 babel-generator。

### Babel做两件事
  - 语法转换：将新的语法转换成低版本浏览器/Node支持的语法
  - polyfill：用低版本浏览器/Node支持的接口hook新的接口/方法

### babel polyfill 有三种
  * babel-polyfill
    - babel-polyfill通过向全局对象和内置对象的prototype上添加方法来实现的。所以这会造成全局空间污染
    - 2种使用方式
      1. webpack.config.js 中： 配置webpack.config.js里的entry设置为entry: ['babel-polyfill',path.join(__dirname, 'index.js')]
      2.  在webpack.config.js配置的主入口index.js文件的最顶层键入
          import 'babel-polyfill'
  * babel-runtime
    -  babel-runtime 更像是一种按需加载的实现
  * babel-plugin-transform-runtime
    - babel-plugin-transform-runtime 装了就不需要装 babel-runtime了，因为前者依赖后者。总的来说，babel-plugin-transform-runtime 就是可以在我们使用新 API 时 自动 import babel-runtime 里面的 polyfill，
    - 具体插件做了以下三件事情：
    1. 当我们使用 async/await 时，自动引入 babel-runtime/regenerator
    2. 当我们使用 ES6 的静态事件或内置对象时，自动引入 babel-runtime/core-js
    3. 移除内联 babel helpers 并替换使用 babel-runtime/helpers  来替换

    - babel-plugin-transform-runtime 优点：
      1. 不会污染全局变量
      2. 多次使用只会打包一次
      3. 依赖统一按需引入,无重复引入,无多余引入
      4. 避免 babel 编译的工具函数在每个模块里重复出现，减小库和工具包的体积
    - 使用方式
      在 .babelrc 中配置：  plugins: ["tranform-runtime"]
# ajax

### 谈谈Ajax，fetch，axios的区

- axios : Axios 能被大量的使用，主要是拥有如下几个特点：
1. 支持 node 端和浏览器端
2. 支持 Promise
3. 丰富的配置项
4. 社区支持
5. 客户端支持防止 CSRF

- fetch :符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里
更好更方便的写法, 更加底层，提供的API丰富（request, response）, 脱离了XHR，是ES规范里新的实现方式
1. fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理
2. fetch默认不会带cookie，需要添加配置项
3. fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费
4. fetch没有办法原生监测请求的进度，而XHR可以


# 小程序
### 小程序如何页面跳转
 1. tabbar跳转
  * wx.switchTab()方法用来跳转至tabBar页面，并关闭其他所有非 tabBar 页面，示例代码如下：

```js 
  wx.switchTab({
    url: '/index'
  })
```
2.跳转到其他页面（非tabBar页)小程序中跳转至其他页面有三种方法，这三种方法分别是是
- wx.redirectTo(): redirectTo方法会关闭当前页面，
- wx.navigateTo() : navigateTo方法并不会关闭当前页面并且页面栈最多十层。
- wx.reLaunch(): reLaunch方法会关闭所有页面

### 微信小程序如何跳转到其他小程序

 - 跳转目标小程序的APPID
 - 使用微信小程序API（wx.navigateToMiniProgram）

 # 项目 

 ### 实现权限管理
 1. 登录权限 
  - 登录访问权限控制是对用户的校验， 在用户登录成功之后， 后台会返回一个token , 之后前端每次进行接口请求的时候，都要带上这个token。后台拿到这个token后进行判断，如果此token确实存在并且没有过期，则可以通过访问。如果token不存在或后台判断已过期，则会跳转到登录页面，要求用户重新登录获取token。
  * 做法一
  ```js 
    <!-- 在用户登录成功的回调中将后台返回的token直接存储到localStorage，然后同步配置请求默认参数的形式将token取出放入headers中传给后台 -->

    let axiosOptions = {
     method,
     url,
     data,
     timeout,
     // 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream'。default json
     responseType,
     // 请求头内追加authToken属性
     headers: {
       authtToken: window.localStorage.getItem(`base/token?`)
     }
   }

  ``` 

  * 做法二
  - 当前项目中使用axios.interceptors.request.use设置发送请求前的拦截,直接将token塞入req.headers.authToken中，作为全局传入。
  ```js
    // axios.interceptors.request.use 请求拦截：配置发送请求的信息
    // axios.interceptors.response.use 响应拦截：配置请求回来的信息

    axios.interceptors.request.use(req => {
      req.headers.authToken = window.localStorage.getItem(`base/token?`)
      return req
    }, error => {
      return Promise.reject(error)
    })

  ```
- vuex + localStorage: 本地通过vuex+localStorage持久化存储token(token:服务端创建用于唯一标识用户身份的Key)。
- axios: 请求拦截验证token，可以使用axios的API:axios.interceptors.request.use，也可以通过添加默认参数的形式在请求头中追加token。

```js
    export const routes = [
      {
         path: '/login', //登录页面
         name: 'Login',
         component: Login,
      },
      {
         path:"/list", // 列表页
         name:"List",
         component: List, 
      },
      {
         path:"/myCenter", // 个人中心
         name:"MyCenter",
         component: MyCenter, 
         meta:{
            need_login:true //需要登录
         }
      }
    ]

```

1. 给路由添加一个meta属性对象， 并将need_login设置为true 
2. 那些需要登录后才能看到的页面,用户如果没有登录就访问,就将页面跳转到登录页.登录成功后跳转到原来指定的页面中
3. 可以通过 router.beforeEach 可以实现，
```js 
//vue-router4 创建路由实例
const router = createRouter({  
  history: createWebHashHistory(),
  routes,
});

router.beforeEach((to, from, next) => {
  const { need_login = false } = to.meta;
  const { user_info } = store.state; //从vuex中获取用户的登录信息
  if (need_login && !user_info) {
    // 如果页面需要登录但用户没有登录跳到登录页面
    const next_page = to.name; // 配置路由时,每一条路由都要给name赋值
    next({
      name: 'Login',
      params: {
        redirect_page: next_page,
        ...from.params, //如果跳转需要携带参数就把参数也传递过去
      },
    });
  } else {
    //不需要登录直接放行
    next();
  }
});

```

### 页面权限控制
1. 首先要有静态路由和动态路由
  - 静态路由： 所有权限都能看到的
  - 动态路由： 定制化角色权限

  ```js 
  import store from "@/store";

  export const routes = [...]; //静态路由

  export const dynamic_routes = [...]; //动态路由

  const router = createRouter({ //创建路由对象
    history: createWebHashHistory(),
    routes,
  });

  //动态添加路由
  if(store.state.user != null){ //从vuex中拿到用户信息
      //用户已经登录
      const { permission_list } = store.state.user; // 从用户信息中获取权限列表
      const allow_routes = dynamic_routes.filter((route)=>{ //过滤允许访问的路由
        return permission_list.includes(route.name); 
      })
      allow_routes.forEach((route)=>{ // 将允许访问的路由动态添加到路由栈中
        router.addRoute(route);
      })
  }

  export default router;

  ```

  核心代码， 利用vue-router提供的*router.addRouter* ,它能够给已经创建的路由实例继续添加路由信息.
  我们先从vuex里面拿到当前用户的权限列表,然后遍历动态路由数组dynamic_routes,从里面过滤出允许访问的路由,最后将这些路由动态添加到路由实例里.
  
  - 嵌套路由
  * vue.addRoute 接受两个参数， 第一个参数， 对应父路由的name , 第二个参数要添加子路由的信息
  ```js 
    router.addRoute("Tabs", {
          path: "/list",
          name: "List",
          component: List,
     });

  ```

  - 内容权限管理
    - 当元素挂载完毕后,通过binding.value获取该元素要求的权限编码.然后拿到当前路由名称,通过路由名称可以在vuex中获取到该用户在该页面所拥有的权限编码.如果该用户不具备访问该元素的权限,就把元素dom移除.
    - 通过v-permission  和 权限编码（curd）


### 平时怎么写项目技术文档，如何进行项目复盘的
  - 平时技术文档都是在熟悉了解需求文档的基础上去写，业务流程，技术选型，接口定义（有些前端定，有些后端定，我们没有太强的归属），然后和后端进行接口对接，定下来交互模式后进行开发 项目复盘主要是从项目遇到的问题，数据情况等进行复盘，说了挺多的


### 前端一键换皮肤
  https://juejin.cn/post/7063010855167721486
 1. css 样式覆盖
  - 在组件中保留不变的样式，将需要变化的样式进行抽离
  - 提供多种样式，给不同的主题定义一个对应的 CSS 选择器
  - 根据不同主题设置不同的样式
  - 缺点： 样式不易管理，查找样式复杂，开发效率低，拓展性差，维护成本高，多人协作沟通麻烦
 2. 实现多套 CSS 主题样式
  - 实现多套 CSS 主题样式，根据用户切换操作，通过 link 标签动态加载不同的主题样式，主要解决了多个主题色被编译到一个文件中导致单个文件过大.
  -  缺点： 需要重复 CV 多份样式文件进行单独修改，没有单独提取出可变的样式部分
 3. CSS 变量实现
  - 通过 body.style.setProperty(key, value) 动态修改 body 上的 CSS 变量，使得页面上的其他部分可以应用最新的 CSS 变量对应的样式.

### npm run dev启动过程
 - https://blog.csdn.net/web2022050901/article/details/125165316
 - 在npm run dev的时候，首先会去项目的package.json文件里找scripts 里找对应的 dev ，然后执行 dev 的命令。

### npm run build 
### npm 发私包
1. 创建账户
2. 登录账号
  > npm login
3. 安装nrm
  >npm install nrm -g
  >nrm ls
  >nrm use npm 
4. 创建项目
5. npm 初始化
  >npm init -y
6. 配置packge.json
  ```js
    {
      "name": "wxdxjs-tools",
      "version": "1.0.0",
      "description": "this is my first package",
      "main": "index.js",
      "private": false,
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1"
      },
      "author": "chenwei",
      "license": "ISC"
    }

  ``` 
7. 创建 README.md
8. 创建 index.js
9. npm 发布
  > npm publish
10. 版本迭代
  需要修改 package.json 的版本号，每次根据需求增加
  ```js
    + "version": "1.0.0"
    - "version": "1.0.1",
  ```


 # 项目兼容问题
  1. ios刘海屏兼容

    ```html
     <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    env()和constant()，是IOS11新增特性，Webkit的css函数，用于设定安全区域与边界的距离，有4个预定义变量：
    safe-area-inset-left：安全区域距离左边边界的距离
    safe-area-inset-right：安全区域距离右边边界的距离
    safe-area-inset-top：安全区域距离顶部边界的距离
    safe-area-inset-bottom ：安全距离底部边界的距离
    ```
    ```js
      "safearea": {
        "background": "#fff",
        "bottom": {
            "offset": "auto"
        }
      }
    ```
  2. 对于yyyy-mm-dd，ios不兼容，ios只认识yyyy/mm/dd 格式 
  3. ios对replaceAll不兼容，使用replace
  4. uniapp 弹窗打开键盘会弹出框过高
    ```js
      // 业务组件
      mounted () {
        this.calcKeyBoard()
      },
      methods: {
        calcKeyBoard () {
          uni.onKeyboardHeightChange(res => {
            let iKeyHeight = res.height
            uni.$emit('keyBoardHeight', res.height)
          })
        },
      }
      ```

    ```js
    mounted() {
      // 获取键盘的高度-提高性能
        if(plus.navigator.hasNotchInScreen()&&(uni.getSystemInfoSync().platform=="ios")){
          uni.$on('keyBoardHeight', res => {
              this.keyBoardHeight = res-plus.navigator.getStatusbarHeight();
          });
        }else{
          uni.$on('keyBoardHeight', res => {
            this.keyBoardHeight = res;
          });
        }
      },
    ```

  5. 软键盘弹出导致屏幕被上移
    - 在 input 中增加:adjust-position="false" 属性
    - 监听软键盘高度，生命周期在 mounted 中uni.onKeyboardHeightChange
    - 通过软键盘高度进行页面内赋值uni .createSelectorQuery() .in(this) .select('id');
    - 视情况可以调整距离，popUp 或者编辑区的 transition
  6. 取消ios 在input 【type= "search"】中自带的搜索图标
    ```css
      ::v-deep [type="search"]::-webkit-search-decoration {
        display: none;
      }
    ```
  7. vue中input 使用回车第一次进入页面的时候总是会刷新
    - 场景： 当页面只有一个input 时， 第一次进入页面（不包含页面进行刷新操作）， input 使用回车总是会刷新， 不会执行搜索
    - 原因： 在form中， 只有一个input 回车会触发页面的提交
    - 解决方法： 在form 表单增加@submit.native.prevent(.native 表示对一个组件绑定系统原生事件, .prevent 表示提交以后不刷新页面)

  8. uniapp uni.$on() 会重复加载调用多次
      - 解决： 在destroyed() {uni.$off("workerListBack"); 卸载掉

### 文件上传
  1. 表单上传
    ```js
      <form action="/index.php" method="POST" enctype="multipart/form-data">
        <input type="file" name="myfile">
        <input type="submit">
      </form>
    ```
  2. 文件编码上传
    - 第一个思路是将文件进行编码，然后在服务端进行解码，其主要实现原理就是将图片转换成base64进行传递
      ```js
        var imgURL = URL.createObjectURL(file);
        ctx.drawImage(imgURL, 0, 0);
        // 获取图片的编码，然后将图片当做是一个很长的字符串进行传递
        var data = canvas.toDataURL("image/jpeg", 0.5); 

        base64编码的缺点在于其体积比原图片更大（因为Base64将三个字节转化成四个字节，因此编码后的文本，会比原文本大出三分之一左右），对于体积很大的文件来说，上传和解析的时间会明显增加。

      ```
    - 前端直接读取文件内容后以二进制格式上传
    ```js
          // 读取二进制文件
      function readBinary(text){
        var data = new ArrayBuffer(text.length);
        var ui8a = new Uint8Array(data, 0);
        for (var i = 0; i < text.length; i++){ 
          ui8a[i] = (text.charCodeAt(i) & 0xff);
        }
        console.log(ui8a)
      }

      var reader = new FileReader();
      reader.onload = function(){
          readBinary(this.result) // 读取result或直接上传
      }
      // 把从input里读取的文件内容，放到fileReader的result字段里
      reader.readAsBinaryString(file);

    ```
  3. formData异步上传
  4. iframe无刷新页面 
  5. 大文件上传
     - 文件切片
      编码方式上传中，在前端我们只要先获取文件的二进制内容，然后对其内容进行拆分，最后将每个切片上传到服务端即可
      ```js
      function slice(file, piece = 1024 * 1024 * 5) {
      let totalSize = file.size; // 文件总大小
      let start = 0; // 每次上传的开始字节
      let end = start + piece; // 每次上传的结尾字节
      let chunks = []
      while (start < totalSize) {
          // 根据长度截取每次需要上传的数据
          // File对象继承自Blob对象，因此包含slice方法
          let blob = file.slice(start, end); 
          chunks.push(blob)

          start = end;
          end = start + piece;
        }
        return chunks
      }

      <!-- 上次服务端 -->
      let file =  document.querySelector("[name=file]").files[0];

      const LENGTH = 1024 * 1024 * 0.1;
      let chunks = slice(file, LENGTH); // 首先拆分切片

      chunks.forEach(chunk=>{
        let fd = new FormData();
        fd.append("file", chunk);
        post('/mkblk.php', fd)
      })

      ```

### vue3 封装 搜索+列表 + 导出 + 分页


# 算法
https://juejin.cn/post/6983904373508145189

## 时间复杂度 
  时间复杂度的计算并不是计算程序具体运行的时间，而是**算法执行语句的次数**。 随着n的不断增大，时间复杂度不断增大，算法花费时间越多。 常见的时间复杂度有

## 空间复杂度 
  空间复杂度是对一个算法在运行过程中**临时占用存储空间的大小**。


### 网络劫持有哪几种，如何防范？

  1. DNS 劫持: (输入京东被强制跳转到淘宝这就属于 dns 劫持)DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导用户流量到缓存服务器302 跳转的方式: 通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的,再对劫持的内存发起 302 跳转的回复，引导用户获取内容
  2. HTTP 劫持: (访问谷歌但是一直有贪玩蓝月的广告),由于 http明文传输,运营商会修改你的 http 响应内容(即加广告)
  3. DNS 劫持由于涉嫌违法，已经被监管起来，现在很少会有 DNS劫持，而http 劫持依然非常盛行，**最有效的办法就是全站 HTTPS，将HTTP 加密，这使得运营商无法获取明文，就无法劫持你的响应内容**。

  ### uniapp中 view标签如何转成div标签  编译器和运行时（runtime）
  Uni-app框架底层通过编译器将跨平台的代码转换为各个平台的原生代码。它使用了一种称为"编译时装配"的技术来实现平台间的转换。
  比如Uni-app，编译时装配技术被广泛应用。Uni-app会根据目标平台的选择，在编译过程中通过编译器对代码进行解析、转换和优化，将跨平台的代码转换为适配目标平台的原生代码。
  具体来说，编译时装配包括以下几个步骤：
  - 代码解析：编译器对源代码进行解析，识别出语法结构和关键信息。
  - 平台适配：根据目标平台的选择，编译器会根据预定义的规则和映射关系，将跨平台的代码转换为目标平台特定的代码。
  - 代码优化：编译器对代码进行优化，包括减少冗余代码、提取公共代码、压缩代码等，以提高代码的执行效率和性能。
  - 生成目标代码：经过转换和优化后，编译器生成适配目标平台的原生代码，可以是机器码、字节码或其他可执行代码形式。


  ### vue 和react区别

  https://juejin.cn/post/6847009771355127822
  https://juejin.cn/post/6844903974437388295
   - 相同点
    1. 都使用Virtural DOM(都是使用Virtual DOM + Diff算法)
    2. 都使用组件化思想，流程基本一致
    3. 都是响应式，推崇单向数据流
    4. 都有成熟的社区，都支持服务端渲染
  - 不同点
    1. react 中，所有的组件的渲染功能都依靠 JSX。   vue使用模板渲染
    2. 渲染方式： Vue使用mvvm数据双向绑定 react单向数据流
