
41
33
（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装
创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一
个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是
简单的封装了复用代码，而没有建立起对象和类型间的关系。
（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，
只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。
执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数
的 prototype 属性，然后将执行上下文中的 this 指向这个对象，
最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因
为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。
构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建
立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存
在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函
数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次
都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有
的实例都可以通用的。
（3）第三种模式是原型模式，因为每一个函数都有一个 prototype
属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例
都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方
法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决
了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有
办法通过传入参数来初始化值，另一个是如果存在一个引用类型如
Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用
类型值的改变会影响所有的实例。
34
（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自
定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存
在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化
对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的
解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使
用了两种不同的模式，所以对于代码的封装性不够好。
（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创
建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以
实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式
很好地对上面的混合模式进行了封装。
（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实
现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，
在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函
数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法
实现对象的识别。
37. 对象继承的方式有哪些？
（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在
的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，
容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传
递参数。
（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子
类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不
能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函
数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。
35
（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数
组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属
性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继
承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我
们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构
造函数，造成了子类型的原型中多了很多不必要的属性。
（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已
有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，
然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为
了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5
中定义的 Object.create() 方法就是原型式继承的实现。缺点与原
型链方式相同。
（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于
封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，
然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解
是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这
个对象不是自定义类型时。缺点是没有办法实现函数的复用。
（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类
型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式
组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这
样就避免了创建不必要的属性。
38. 哪些情况会导致内存泄漏
以下四种情况会造成内存的泄漏：
36
意外的全局变量：由于使用未声明的变量，而意外的创建了一个全局
变量，而使这个变量一直留在内存中无法被回收。
被遗忘的计时器或回调函数：设置了 setInterval 定时器，而忘记
取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被
一直留在内存中，而无法被回收。
脱离 DOM 的引用：获取一个 DOM 元素的引用，而后面这个元素被删
除，由于一直保留了对这个元素的引用，所以它也无法被回收。
闭包：不合理的使用闭包，从而导致某些变量一直被留在内存当中。
VUE 部分
1. Vue 的基本原理
当 一 个 Vue 实 例 创 建 时 ， Vue 会 遍 历 data 中 的 属 性 ， 用
Object.defineProperty （ vue3.0 使 用 proxy ） 将 它 们 转 为
getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时
通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组
件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用
时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。
37
2. 双向数据绑定的原理
Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过
Object.defineProperty()来劫持各个属性的 setter，getter，在数
据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几
个步骤：
1.需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，
都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会
触发 setter，那么就能监听到了数据变化
2.compile 解析模板指令，将模板中的变量替换成数据，然后初始化
渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数
据的订阅者，一旦数据有变动，收到通知，更新视图
3.Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做
的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②
自身必须有一个 update()方法 ③待属性变动 dep.notice()通知时，
能调用自身的 update()方法，并触发 Compile 中绑定的回调，则功
成身退。
4.MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher
三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile
来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile
之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input)
-> 数据 model 变更的双向绑定效果。
38
3. MVVM、MVC、MVP 的区别
MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离
关注点的方式来组织代码结构，优化开发效率。
在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有
的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户
事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，
可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗
长、混乱，这样对项目开发和后期的项目维护是非常不利的。
（1）MVC
MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。
其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，
以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，
当 Model 层发生改变的时候它会通知有关 View 层更新页面。
39
Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应
用的响应操作，当用户与页面产生交互的时候，Controller 中的事
件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修
改，然后 Model 层再去通知 View 层更新。
（2）MVVM
MVVM 分为 Model、View、ViewModel：
Model 代表数据模型，数据和业务逻辑都在 Model 层中定义；
View 代表 UI 视图，负责数据的展示；
ViewModel 负责监听 Model 中数据的改变并且控制视图的更新，处理
用户交互操作；
Model 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，
Model 和 ViewModel 之间有着双向数据绑定的联系。因此当 Model 中
的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改
变的数据也会在 Model 中同步。
这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要
专注于数据的维护操作即可，而不需要自己操作 DOM。
40
（3）MVP
MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在
MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时
候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，
当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对
代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实
现对 View 层和 Model 层的解耦。MVC 中的 Controller 只知道
Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，
View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将
Model 的变化和 View 的变化绑定在一起，以此来实现 View 和
Model 的同步更新。这样就实现了对 View 和 Model 的解耦，
Presenter 还包含了其他的响应逻辑。
4. slot 是什么？有什么作用？原理是什么？
slot 又名插槽，是 Vue 的内容分发机制，组件内部的模板引擎使用
slot 元素作为承载分发内容的出口。插槽 slot 是子组件的一个模板
标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决
定的。slot 又分三类，默认插槽，具名插槽和作用域插槽。
默认插槽：又名匿名插槽，当 slot 没有指定 name 属性值的时候一个
默认显示插槽，一个组件内只有有一个匿名插槽。
41
具名插槽：带有具体名字的插槽，也就是带有 name 属性的 slot，一
个组件可以出现多个具名插槽。
作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也
可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可
以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过
来的数据决定如何渲染该插槽。
实现原理：当子组件 vm 实例化时，获取到父组件传入的 slot 标签的
内容，存放在 vm.$slot 中，默认插槽为 vm.$slot.default，具名插
槽为 vm.$slot.xxx，xxx 为插槽名，当组件执行渲染函数时候，遇
到 slot 标签，使用$slot 中的内容进行替换，此时可以为插槽传递
数据，若存在数据，则可称该插槽为作用域插槽。
5. $nextTick 原理及作用
Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的
一种应用。
nextTick 的 核 心 是 利 用 了 如 Promise 、 MutationObserver 、
setImmediate、setTimeout 的原生 JavaScript 方法来模拟对应的
微/宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任
务队列来实现 Vue 框架中自己的异步回调队列。
nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发
者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时
机的后续逻辑处理
nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中
的示例，引入异步更新队列机制的原因∶
42
如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI/DOM
的渲染，可以减少一些无用渲染
同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的
信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更
新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后
的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所
以异步渲染变得更加至关重要
Vue 采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作
DOM。有时候，可能遇到这样的情况，DOM1 的数据发生了变化，而 DOM2
需要从 DOM1 中获取数据，那这时就会发现 DOM2 的视图并没有更新，
这时就需要用到了 nextTick 了。
由于 Vue 的 DOM 操作是异步的，所以，在上面的情况中，就要将 DOM2
获取数据的操作写在$nextTick 中。
所以，在以下情况下，会用到 nextTick：
在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变
化的 DOM 结构的时候，这个操作就需要方法在 nextTick()的回调函
数中。
在 vue 生命周期中，如果在 created()钩子进行 DOM 操作，也一定要
放在 nextTick()的回调函数中。
因为在 created()钩子函数中，页面的 DOM 还未渲染，这时候也没办
法操作 DOM，所以，此时如果想要操作 DOM，必须将操作的代码放在
nextTick()的回调函数中。




52
如 果 没 有 彻 底 解 决 问 题 ， 则 在 根 元 素 加 上 style="display:
none;" :style="{display: 'block'}"
17. MVVM 的优缺点?
优点:
分离视图（View）和模型（Model），降低代码耦合，提高视图或者
逻辑的重用性: 比如视图（View）可以独立于 Model 变化和修改，一
个 ViewModel 可以绑定不同的"View"上，当 View 变化的时候 Model
不可以不变，当 Model 变化的时候 View 也可以不变。你可以把一些
视图逻辑放在一个 ViewModel里面，让很多 view 重用这段视图逻辑
提高可测试性: ViewModel 的存在可以帮助开发者更好地编写测试代
码
自动更新 dom: 利用双向绑定,数据更新后视图自动更新,让开发者从
繁琐的手动 dom 中解放
缺点:
Bug 很难被调试: 因为使用双向绑定的模式，当你看到界面异常了，
有可能是你 View 的代码有 Bug，也可能是 Model 的代码有问题。数
据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问
题的地方就变得不那么容易了。另外，数据绑定的声明是指令式地写
在 View 的模版当中的，这些内容是没办法去打断点 debug 的
一个大的模块中 model 也会很大，虽然使用方便了也很容易保证了数
据的一致性，当时⻓期持有，不释放内存就造成了花费更多的内存
53
对于大型的图形应用程序，视图状态较多，ViewModel 的构建和维护
的成本都会比较高。
18. v-if 和 v-for 哪个优先级更高？如果同时出现，应如何优
化？
v-for 优先于 v-if 被解析，如果同时出现，每次渲染都会先执行循
环再判断条件，无论如何循环都不可避免，浪费了性能。
要避免出现这种情况，则在外层嵌套 template，在这一层进行 v-if
判断，然后在内部进行 v-for 循环。如果条件出现在循环内部，可通
过计算属性提前过滤掉那些不需要显示的项。
19. 对 Vue 组件化的理解
1.组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之
一，它使开发者使用小型、独立和通常可复用的组件构建大型应用；
2.组件化开发能大幅提高应用开发效率、测试性、复用性等；
3.组件使用按分类有：页面组件、业务组件、通用组件；
4.vue 的组件是基于配置的，我们通常编写的组件是组件配置而非组
件，框架后续会生成其构造函数，它们基于 VueComponent，扩展于
Vue；
5.vue 中常见组件化技术有：属性 prop，自定义事件，插槽等，它们
主要用于组件通信、扩展等；6.合理的划分组件，有助于提升应用性
能；
6.组件应该是高内聚、低耦合的；
7.遵循单向数据流的原则。
20. 对 vue 设计原则的理解
54
1.渐进式 JavaScript 框架：与其它大型框架不同的是，Vue 被设计
为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上
手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工
具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应
用提供驱动。
2.易用性：vue 提供数据响应式、声明式模板语法和基于配置的组件
系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要
会写 js、html 和 css 就能轻松编写 vue 应用。
3.灵活性：渐进式框架的最大优点就是灵活性，如果应用足够小，我
们可能仅需要 vue 核心特性即可完成功能；随着应用规模不断扩大，
我们才可能逐渐引入路由、状态管理、vue-cli 等库和工具，不管是
应用体积还是学习难度都是一个逐渐增加的平和曲线。
4.高效性：超快的虚拟 DOM 和 diff算法使我们的应用拥有最佳的性能
表现。追求高效的过程还在继续，vue3 中引入 Proxy 对数据响应式
改进以及编译器中对于静态内容编译的改进都会让 vue 更加高效。
21. 说一下 Vue 的生命周期
Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、
编译模版、挂载 Dom -> 渲染、更新 -> 渲染、卸载 等一系列过程，
称这是 Vue 的生命周期。
1.beforeCreate（创建前）：数据观测和初始化事件还未开始，此时
data 的响应式追踪、event/watcher 都还没有被设置，也就是说不
能访问到 data、computed、watch、methods 上的方法和数据。
55
2.created（创建后） ：实例创建完成，实例上配置的 options 包
括 data、computed、watch、methods 等都配置完成，但是此时渲染
得节点还未挂载到 DOM，所以不能访问到 $el 属性。
3.beforeMount（挂载前）：在挂载开始之前被调用，相关的 render
函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面
的数据和模板生成 html。此时还没有挂载 html 到页面上。
4.mounted（挂载后）：在 el 被新创建的 vm.$el 替换，并挂载到实
例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内
容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页
面中。此过程中进行 ajax 交互。
5.beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应
式数据更新了，但是对应的真实 DOM 还没有被渲染。
6.updated（更新后） ：在由于数据更改导致的虚拟 DOM 重新渲染和
打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调
用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而
在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更
新无限循环。该钩子在服务器端渲染期间不被调用。
7.beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍
然完全可用，this 仍能获取到实例。
8.destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示
的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例
也会被销毁。该钩子在服务端渲染期间不被调用。
56
另外还有 keep-alive 独有的生命周期，分别为 activated 和
deactivated。用 keep-alive 包裹的组件在切换时不会进行销毁，而
是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执
行 activated 钩子函数。
22. Vue 子组件和父组件执行顺序
加载渲染过程：
1.父组件 beforeCreate
2.父组件 created
3.父组件 beforeMount
4.子组件 beforeCreate
5.子组件 created
6.子组件 beforeMount
7.子组件 mounted
8.父组件 mounted
更新过程：
1. 父组件 beforeUpdate
2.子组件 beforeUpdate
3.子组件 updated
4.父组件 updated
销毁过程：
1. 父组件 beforeDestroy
57
2.子组件 beforeDestroy
3.子组件 destroyed
4.父组件 destoryed
23. created 和 mounted 的区别
created:在模板渲染成 html 前调用，即通常初始化某些属性值，然
后再渲染成视图。
mounted:在模板渲染成 html 后调用，通常是初始化页面完成后，再
对 html 的 dom 节点进行一些需要的操作。
4. 一般在哪个生命周期请求异步数据
我们可以在钩子函数 created、beforeMount、mounted 中进行调用，
因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的
数据进行赋值。
推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函
数中调用异步请求有以下优点：
能更快获取到服务端数据，减少页面加载时间，用户体验更好；
SSR 不支持 beforeMount 、mounted 钩子函数，放在 created 中有
助于一致性。
24. keep-alive 中的生命周期哪些
keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存——
在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。
58
如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：
deactivated、activated。同时，beforeDestroy 和 destroyed 就
不会再被触发了，因为组件不会被真正销毁。
当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；
当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子
函数。
25. 路由的 hash 和 history 模式的区别
Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模
式是 hash 模式。
1. hash 模式
简介： hash 模式是开发中默认的模式，它的 URL 带着一个#，例如：
http://www.abc.com/#/vue，它的 hash 值就是#/vue。
特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对
后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模
式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash
路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。
原理： hash 模式的主要原理就是 onhashchange()事件：
使用 onhashchange()事件的好处就是，在页面的 hash 值发生变化时，
无需向后端发起请求，window 就可以监听事件的改变，并按规则加
载相应的代码。除此之外，hash 值变化对应的 URL 都会被浏览器记
59
录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后
端服务器，但是页面的 hash 值和对应的 URL 关联起来了。
2. history 模式
简介： history 模式的 URL 中没有#，它使用的是传统的路由分发模
式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个
URL，然后做出相应的逻辑处理。
特 点 ： 当 使 用 history 模 式 时 ， URL 就 像 这 样 ：
http://abc.com/user/id。相比 hash 模式更加好看。但是，history
模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。
API： history api 可以分为两大部分，切换历史状态和修改历史状
态：
修 改 历 史 状 态 ： 包 括 了 HTML5 History Interface 中 新 增 的
pushState() 和 replaceState() 方法，这两个方法应用于浏览器的
历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修
改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要
做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。
切换历史状态： 包括 forward()、back()、go()三个方法，对应浏
览器的前进，后退，跳转操作。
虽然 history 模式丢弃了丑陋的#。但是，它也有自己的缺点，就是
在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。
如果想要切换到 history 模式，就要进行以下配置（后端也要进行配
置）：
60
3. 两种模式对比
调用 history.pushState() 相比于直接修改 hash，存在以下优势:
pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而
hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的
URL；
pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把
记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动
作将记录添加到栈中；
pushState() 通过 stateObject 参数可以添加任意类型的数据到记
录中；而 hash 只可添加短字符串；
pushState() 可额外设置 title 属性供后续使用。
hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果
没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，
前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的
路由处理，将返回 404 错误。
hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际
情况选择性的使用。
26. Vue-router 跳转和 location.href 有什么区别
使用 location.href= /url 来跳转，简单方便，但是刷新了页面；





<!-- ============== -->

63
55
2.created（创建后） ：实例创建完成，实例上配置的 options 包
括 data、computed、watch、methods 等都配置完成，但是此时渲染
得节点还未挂载到 DOM，所以不能访问到 $el 属性。
3.beforeMount（挂载前）：在挂载开始之前被调用，相关的 render
函数首次被调用。实例已完成以下的配置：编译模板，把 data 里面
的数据和模板生成 html。此时还没有挂载 html 到页面上。
4.mounted（挂载后）：在 el 被新创建的 vm.$el 替换，并挂载到实
例上去之后调用。实例已完成以下的配置：用上面编译好的 html 内
容替换 el 属性指向的 DOM 对象。完成模板中的 html 渲染到 html 页
面中。此过程中进行 ajax 交互。
5.beforeUpdate（更新前）：响应式数据更新时调用，此时虽然响应
式数据更新了，但是对应的真实 DOM 还没有被渲染。
6.updated（更新后） ：在由于数据更改导致的虚拟 DOM 重新渲染和
打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调
用时，组件 DOM 已经更新，所以可以执行依赖于 DOM 的操作。然而
在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更
新无限循环。该钩子在服务器端渲染期间不被调用。
7.beforeDestroy（销毁前）：实例销毁之前调用。这一步，实例仍
然完全可用，this 仍能获取到实例。
8.destroyed（销毁后）：实例销毁后调用，调用后，Vue 实例指示
的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例
也会被销毁。该钩子在服务端渲染期间不被调用。
56
另外还有 keep-alive 独有的生命周期，分别为 activated 和
deactivated。用 keep-alive 包裹的组件在切换时不会进行销毁，而
是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执
行 activated 钩子函数。
22. Vue 子组件和父组件执行顺序
加载渲染过程：
1.父组件 beforeCreate
2.父组件 created
3.父组件 beforeMount
4.子组件 beforeCreate
5.子组件 created
6.子组件 beforeMount
7.子组件 mounted
8.父组件 mounted
更新过程：
1. 父组件 beforeUpdate
2.子组件 beforeUpdate
3.子组件 updated
4.父组件 updated
销毁过程：
1. 父组件 beforeDestroy
57
2.子组件 beforeDestroy
3.子组件 destroyed
4.父组件 destoryed
23. created 和 mounted 的区别
created:在模板渲染成 html 前调用，即通常初始化某些属性值，然
后再渲染成视图。
mounted:在模板渲染成 html 后调用，通常是初始化页面完成后，再
对 html 的 dom 节点进行一些需要的操作。
4. 一般在哪个生命周期请求异步数据
我们可以在钩子函数 created、beforeMount、mounted 中进行调用，
因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的
数据进行赋值。
推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函
数中调用异步请求有以下优点：
能更快获取到服务端数据，减少页面加载时间，用户体验更好；
SSR 不支持 beforeMount 、mounted 钩子函数，放在 created 中有
助于一致性。
24. keep-alive 中的生命周期哪些
keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存——
在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。
58
如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：
deactivated、activated。同时，beforeDestroy 和 destroyed 就
不会再被触发了，因为组件不会被真正销毁。
当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；
当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子
函数。
25. 路由的 hash 和 history 模式的区别
Vue-Router 有两种模式：hash 模式和 history 模式。默认的路由模
式是 hash 模式。
1. hash 模式
简介： hash 模式是开发中默认的模式，它的 URL 带着一个#，例如：
http://www.abc.com/#/vue，它的 hash 值就是#/vue。
特点：hash 值会出现在 URL 里面，但是不会出现在 HTTP 请求中，对
后端完全没有影响。所以改变 hash 值，不会重新加载页面。这种模
式的浏览器支持度很好，低版本的 IE 浏览器也支持这种模式。hash
路由被称为是前端路由，已经成为 SPA（单页面应用）的标配。
原理： hash 模式的主要原理就是 onhashchange()事件：
使用 onhashchange()事件的好处就是，在页面的 hash 值发生变化时，
无需向后端发起请求，window 就可以监听事件的改变，并按规则加
载相应的代码。除此之外，hash 值变化对应的 URL 都会被浏览器记
59
录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后
端服务器，但是页面的 hash 值和对应的 URL 关联起来了。
2. history 模式
简介： history 模式的 URL 中没有#，它使用的是传统的路由分发模
式，即用户在输入一个 URL 时，服务器会接收这个请求，并解析这个
URL，然后做出相应的逻辑处理。
特 点 ： 当 使 用 history 模 式 时 ， URL 就 像 这 样 ：
http://abc.com/user/id。相比 hash 模式更加好看。但是，history
模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404。
API： history api 可以分为两大部分，切换历史状态和修改历史状
态：
修 改 历 史 状 态 ： 包 括 了 HTML5 History Interface 中 新 增 的
pushState() 和 replaceState() 方法，这两个方法应用于浏览器的
历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修
改时，虽然修改了 url，但浏览器不会立即向后端发送请求。如果要
做到改变 url 但又不刷新页面的效果，就需要前端用上这两个 API。
切换历史状态： 包括 forward()、back()、go()三个方法，对应浏
览器的前进，后退，跳转操作。
虽然 history 模式丢弃了丑陋的#。但是，它也有自己的缺点，就是
在刷新页面的时候，如果没有相应的路由或资源，就会刷出 404 来。
如果想要切换到 history 模式，就要进行以下配置（后端也要进行配
置）：
60
3. 两种模式对比
调用 history.pushState() 相比于直接修改 hash，存在以下优势:
pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而
hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的
URL；
pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把
记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动
作将记录添加到栈中；
pushState() 通过 stateObject 参数可以添加任意类型的数据到记
录中；而 hash 只可添加短字符串；
pushState() 可额外设置 title 属性供后续使用。
hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果
没有做到对路由的全覆盖，也不会返回 404 错误；history 模式下，
前端的 url 必须和实际向后端发起请求的 url 一致，如果没有对用的
路由处理，将返回 404 错误。
hash 模式和 history 模式都有各自的优势和缺陷，还是要根据实际
情况选择性的使用。
26. Vue-router 跳转和 location.href 有什么区别
使用 location.href= /url 来跳转，简单方便，但是刷新了页面；
使用 history.pushState( /url ) ，无刷新页面，静态跳转；
61
引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff
算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳
转和使用 history.pushState() 没什么差别的，因为 vue-router 就
是用了 history.pushState() ，尤其是在 history 模式下。
27. Vuex 的原理
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个
Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个
容器，它包含着你的应用中大部分的状态 ( state )。
Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的
时候，若 store 中的状态发生变化，那么相应的组件也会相应地得
到高效更新。
改 变 store 中 的 状 态 的 唯 一 途 径 就 是 显 式 地 提 交 (commit)
mutation。这样可以方便地跟踪每一个状态的变化。
62
Vuex 为 Vue Components 建立起了一个完整的生态圈，包括开发中的
API 调用一环。
（1）核心流程中的主要功能：
Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或
动作，也就是图中的 Actions;
在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex
中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提
交（Commit）到 Mutations 中;
然后 Mutations 就去改变（Mutate）State 中的数据;
当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue
Components 中去，组件展示更新后的数据，完成一个流程。
（2）各模块在核心流程中的主要功能：
Vue Components∶ Vue 组件。HTML 页面上，负责接收用户操作等交
互行为，执行 dispatch 方法触发对应 action 进行回应。
dispatch∶操作行为触发方法，是唯一能执行 action 的方法。
actions∶ 操作行为处理模块。负责处理 Vue Components 接收到的
所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册
的顺序依次触发。向后台 API 请求的操作就在这个模块中进行，包括
触发其他 action 以及提交 mutation 的操作。该模块提供了 Promise
的封装，以支持 action 的链式触发。
commit∶状态改变提交操作方法。对 mutation 进行提交，是唯一能
执行 mutation 的方法。
63
mutations∶状态改变操作方法。是 Vuex 修改 state 的唯一推荐方法，
其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且
方法名只能全局唯一。操作之中会有一些 hook 暴露出来，以进行
state 的监控等。
state∶ 页面状态管理容器对象。集中存储 Vuecomponents 中 data
对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需
的数据从该对象中进行读取，利用 Vue 的细粒度数据响应机制来进行
高效的状态更新。
getters∶ state 对象读取方法。图中没有单独列出该模块，应该被
包含在了 render 中，Vue Components 通过该方法读取全局 state 对
象。
总结：
Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当
组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息，
Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据
的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)
或批量的同步操作需要走 Action ，但 Action 也是无法直接修改
State 的，还是需要通过 Mutation 来修改 State 的数据。最后，根
据 State 的变化，渲染到视图上。
28. Vuex 和 localStorage 的区别
（1）最重要的区别
vuex 存储在内存中
64
localstorage 则以文件的方式存储在本地，只能存储字符串类型的
数据，存储对象需要 JSON 的 stringify 和 parse 方法进行处理。 读
取内存比读取硬盘速度要快
（2）应用场景
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集
中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一
种可预测的方式发生变化。vuex 用于组件之间的传值。
localstorage 是本地存储，是将数据存储到浏览器的方法，一般是
在跨页面传递数据时使用 。
Vuex 能做到数据的响应式，localstorage 不能
（3）永久性
刷新页面时 vuex 存储的值会丢失，localstorage 不会。
注意：对于不变的数据确实可以用 localstorage 可以代替 vuex，但
是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件
改变了该数据源，希望另一个组件响应该变化时，localstorage 无
法做到，原因就是区别 1。
29. Redux 和 Vuex 有什么区别，它们的共同思想
（1）Redux 和 Vuex 区别
Vuex 改进了 Redux 中的 Action 和 Reducer 函数，以 mutations 变化
函数取代 Reducer，无需 switch，只需在对应的 mutation 函数里改
变 state 值即可
Vuex 由于 Vue 自动重新渲染的特性，无需订阅重新渲染函数，只要
生成新的 State 即可











77
实例：一个实例 instance 是你在所写的组件类 component class 中
使用关键字 this 所指向的东西(译注:组件实例)。它用来存储本地状
态和响应生命周期事件很有用。
函数式组件(Functional component)根本没有实例 instance。类组
件(Class component)有实例 instance，但是永远也不需要直接创建
一个组件的实例，因为 React 帮我们做了这些。
5. React.createClass 和 extends Component 的区别有哪些？
React.createClass 和 extends Component 的 bai 区别主要在于：
（1）语法区别
createClass 本质上是一个工厂函数，extends 的方式更加接近最新
的 ES6 规范的 class 写法。两种方式在语法上的差别主要体现在方法
的定义和静态属性的声明上。
createClass 方式的方法定义使用逗号，隔开，因为 creatClass 本
质上是一个函数，传递给它的是一个 Object；而 class 的方式定义
方法时务必谨记不要使用逗号隔开，这是 ES6 class 的语法规范。
（2）propType 和 getDefaultProps
React.createClass：通过 proTypes 对象和 getDefaultProps()方法
来设置和获取 props.
React.Component：通过设置两个属性 propTypes 和 defaultProps
（3）状态的区别
React.createClass：通过 getInitialState()方法返回一个包含初
始值的对象
React.Component：通过 constructor 设置初始状态
78
（4）this 区别
React.createClass：会正确绑定 this
React.Component：由于使用了 ES6，这里会有些微不同，属性并不
会自动绑定到 React 类的实例上。
（5）Mixins
React.createClass：使用 React.createClass 的话，可以在创建组
件时添加一个叫做 mixins 的属性，并将可供混合的类的集合以数组
的形式赋给 mixins。
如果使用 ES6 的方式来创建组件，那么 React mixins 的特性将不
能被使用了。
6. React 如何判断什么时候重新渲染组件？
组件状态的改变可以因为 props 的改变，或者直接通过 setState 方
法改变。组件获得新的状态，然后 React 决定是否应该重新渲染组件。
只要组件的 state 发生变化，React 就会对组件进行重新渲染。这是
因为 React 中的 shouldComponentUpdate 方法默认返回 true，这就
是导致每次更新都重新渲染的原因。
当 React 将要渲染组件时会执行 shouldComponentUpdate 方法来看它
是否返回 true（组件应该更新，也就是重新渲染）。所以需要重写
shouldComponentUpdate 方法让它根据情况返回 true 或者 false 来
告诉 React 什么时候重新渲染什么时候跳过重新渲染。
7. React 中可以在 render 访问 refs 吗？为什么？
不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取
需要在 pre-commit 阶段和 commit 阶段：
79
8. React setState 调用之后发生了什么？是同步还是异步？
（1）React 中 setState 后发生了什么
在代码中调用 setState 函数之后，React 会将传入的参数对象与组
件当前的状态合并，然后触发调和过程(Reconciliation)。经过调和
过程，React 会以相对高效的方式根据新的状态构建 React 元素树
并且着手重新渲染整个 UI 界面。
在 React 得到元素树之后，React 会自动计算出新的树与老树的节
点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，
React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，
这就保证了按需更新，而不是全部重新渲染。
如果在短时间内频繁 setState。React 会将 state 的改变压入栈中，
在合适的时机，批量更新 state 和视图，达到提高性能的效果。
（2）setState 是同步还是异步的
80
假如所有 setState 是同步的，意味着每执行一次 setState 时（有可
能一个同步代码中，多次 setState），都重新 vnode diff + dom 修
改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代
码中的多个 setState 合并成一次组件更新。所以默认是异步的，但
是在一些情况下是同步的。
setState 并不是单纯同步/异步的，它的表现会因调用场景的不同而
不同。在源码中，通过 isBatchingUpdates 来判断 setState 是先
存进 state 队列还是直接更新，如果值为 true 则执行异步操作，
为 false 则直接更新。
异步：在 React 可以控制的地方，就为 true，比如在 React 生命
周期事件和合成事件中，都会走合并操作，延迟更新的策略。
同步：在 React 无法控制的地方，比如原生事件，具体就是在
addEventListener 、setTimeout、setInterval 等事件中，就只能
同步更新。
一般认为，做异步设计是为了性能优化、减少渲染次数：
setState 设计为异步，可以显著的提升性能。如果每次调用 setState
都进行一次更新，那么意味着 render 函数会被频繁调用，界面重新
渲染，这样效率是很低的；最好的办法应该是获取到多个更新，之后
进行批量更新；
如果同步更新了 state，但是还没有执行 render 函数，那么 state
和 props 不能保持同步。state 和 props 不能保持一致性，会在开发
中产生很多的问题；
9. React 组件的 state 和 props 有什么区别？
（1）props
81
props 是一个从外部传进组件的参数，主要作为就是从父组件向子组
件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新
的 props 来重新渲染子组件，否则子组件的 props 以及展现形式不会
改变。
（2）state
state 的主要作用是用于组件保存、控制以及修改自己的状态，它只
能在 constructor 中初始化，它算是组件的私有属性，不可通过外部
访问和修改，只能通过组件内部的 this.setState 来修改，修改 state
属性会导致组件的重新渲染。
（3）区别
props 是传递给组件的（类似于函数的形参），而 state 是在组件
内被组件自己管理的（类似于在一个函数内声明的变量）。
props 是不可修改的，所有 React 组件都必须像纯函数一样保护它
们的 props 不被更改。
state 是在组件中创建的，一般在 constructor 中初始化 state。
state 是多变的、可以修改，每次 setState 都异步更新的。
10. React 中的 props 为什么是只读的？
this.props 是组件之间沟通的一个接口，原则上来讲，它只能从父
组件流向子组件。React 具有浓重的函数式编程的思想。
提到函数式编程就要提一个概念：纯函数。它有几个特点：
给定相同的输入，总是返回相同的输出。
过程没有副作用。
不依赖外部状态。
82
this.props 就是汲取了纯函数的思想。props 的不可以变性就保证的
相同的输入，页面显示的内容是一样的，并且不会产生副作用
11. React 中怎么检验 props？验证 props 的目的是什么？
React 为我们提供了 PropTypes 以供验证使用。当我们向 Props 传入
的数据无效（向 Props 传入的数据类型和验证的数据类型不符）就会
在控制台发出警告信息。它可以避免随着应用越来越复杂从而出现的
问题。并且，它还可以让程序变得更易读。
当然，如果项目汇中使用了 TypeScript，那么就可以不用 PropTypes
来校验，而使用 TypeScript 定义接口来校验 props。
2. React 废弃了哪些生命周期？为什么？
被废弃的三个函数都是在 render 之前，因为 fber 的出现，很可能因
为高优先级任务的出现而打断现有任务导致它们会被执行多次。另外
的一个原因则是，React 想约束使用者，好的框架能够让人不得已写
出容易维护和扩展的代码，这一点又是从何谈起，可以从新增加以及
即将废弃的生命周期分析入手
1) componentWillMount
首先这个函数的功能完全可以使用 componentDidMount 和
constructor 来代替，异步获取的数据的情况上面已经说明了，而如
83
果抛去异步获取数据，其余的即是初始化而已，这些功能都可以在
constructor 中执行，除此之外，如果在 willMount 中订阅事件，
但在服务端这并不会执行 willUnMount 事件，也就是说服务端会导
致内存泄漏所以 componentWilIMount 完全可以不使用，但使用者有
时候难免因为各 种各样的情况在 componentWilMount 中做一些操作，
那么 React 为了约束开发者，干脆就抛掉了这个 API
2) componentWillReceiveProps
在老版本的 React 中，如果组件自身的某个 state 跟其 props 密
切相关的话，一直都没有一种很优雅的处理方式去更新 state，而是
需要在 componentWilReceiveProps 中判断前后两个 props 是否相
同，如果不同再将新的 props 更新到相应的 state 上去。这样做一
来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，
另一方面也会增加组件的重绘次数。类似的业务需求也有很多，如一
个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的时，
根据传入的某个值，直接定位到某个 Tab。为了解决这些问题，React
引入了第一个新的生命周期：getDerivedStateFromProps。它有以下
的优点∶
●getDSFP 是静态方法，在这里不能使用 this，也就是一个纯函数，
开发者不能写出副作用的代码
●开发者只能通过 prevState 而不是 prevProps 来做对比，保证了
state 和 props 之间的简单关系以及不需要处理第一次渲染时
prevProps 为空的情况
●基于第一点，将状态变化（setState）和昂贵操作（tabChange）
区分开，更加便于 render 和 commit 阶段操作或者说优化。
3) componentWillUpdate
84
与 componentWillReceiveProps 类似，许多开发者也会在
componentWillUpdate 中根据 props 的变化去触发一些回调 。 但
不论是 componentWilReceiveProps 还 是 componentWilUpdate，都
有可能在一次更新中被调用多次，也就是说写在这里的回调函数也有
可能会被调用多次，这显然是不可取的。与 componentDidMount 类
似， componentDidUpdate 也不存在这样的问题，一次更新中
componentDidUpdate 只会被调用一次，所以将原先写在
componentWillUpdate 中 的 回 调 迁 移 至 componentDidUpdate
就可以解决这个问题。
另外一种情况则是需要获取 DOM 元素状态，但是由于在 fber 中，
render 可打断，可能在 wilMount 中获取到的元素状态很可能与实际
需要的不同，这个通常可以使用第二个新增的生命函数的解决
getSnapshotBeforeUpdate(prevProps, prevState)
4) getSnapshotBeforeUpdate(prevProps, prevState)
返回的值作为 componentDidUpdate 的第三个参数。与 willMount 不
同的是，getSnapshotBeforeUpdate 会在最终确定的 render 执行之
前执行，也就是能保证其获取到的元素状态与 didUpdate 中获取到的



Babel 的原理是什么?
babel 的转译过程也分为三个阶段，这三步具体是：
解析 Parse: 将代码解析生成抽象语法树（AST），即词法分析与语
法分析的过程；
转换 Transform: 对于 AST 进行变换一系列的操作，babel 接受得
到 AST 并通过 babel-traverse 对其进行遍历，在此过程中进行添
加、更新及移除等操作；
122
生成 Generate: 将变换后的 AST 再转换为 JS 代码, 使用到的模
块是 babel-generator。
9. git 和 svn 的区别
git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。
因此我们不能再离线的情况下使用 svn。如果服务器出现问题，就没
有办法使用 svn 来提交代码。
svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支
是指针指向某次提交，因此 git 的分支创建更加开销更小并且分支
上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。
svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。
GIT 把内容按元数据方式存储，而 SVN 是按文件：因为 git 目录是处
于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东
西，例如标签，分支，版本记录等。
GIT 分支和 SVN 的分支不同：svn 会发生分支遗漏的情况，而 git 可
以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并
的分支，简单而快捷的合并这些文件。
GIT 没有一个全局的版本号，而 SVN 有
123
GIT 的内容完整性要优于 SVN：GIT 的内容存储使用的是 SHA-1 哈希
算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题




网络劫持有哪几种，如何防范？
网络劫持分为两种:
（1）DNS 劫持: (输入京东被强制跳转到淘宝这就属于 dns 劫持)
DNS 强制解析: 通过修改运营商的本地 DNS 记录，来引导用户流量到
缓存服务器
302 跳转的方式: 通过监控网络出口的流量，分析判断哪些内容是可
以进行劫持处理的,再对劫持的内存发起 302 跳转的回复，引导用户
获取内容
（2）HTTP 劫持: (访问谷歌但是一直有贪玩蓝月的广告),由于 http
明文传输,运营商会修改你的 http 响应内容(即加广告)
（3）DNS 劫持由于涉嫌违法，已经被监管起来，现在很少会有 DNS
劫持，而http 劫持依然非常盛行，最有效的办法就是全站 HTTPS，将
HTTP 加密，这使得运营商无法获取明文，就无法劫持你的响应内容。
7. 浏览器渲染进程的线程有哪些
浏览器的渲染进程的线程总共有五种：



对浏览器的缓存机制的理解
浏览器缓存的全过程：
浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源
文件，并缓存资源文件与 response header，以供下次加载时对比使
用；
下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上
一次返回 200 时的时间差，如果没有超过 cache-control 设置的
max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果
浏览器不支持 HTTP1.1，则使用 expires 头判断是否过期；
134
如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向
服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做
修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不
一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；
如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和
被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；
不一致则返回新的 last-modified 和文件并返回 200；
很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS
或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户
端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时
获得网站的最新更新。


 webpack是一个串行的过程， 从启动到结束会 依次执行以下顺序
 - 初始化参数： 从配置文件和shell语句中读取和合并参数，得出最终参数
 - 开始编译： 用上一步得到的参数complier对象，加载所有配置的插件， 执行对象的run方法开始执行编译
 - 确定入口： 根据配置中的entry找出所有入口文件
 - 模块化编译： 从入口文件出发， 调用所有配置的loader对模块进行编译， 在找出改模块的依赖模块， 再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
 - 完成模块编译： 在经过第四步使用loader翻译完所有模块后， 得到每个模块被翻译后的最终内容以及他们之间的依赖关系
 - 输出资源： 根据入口和模块之间的依赖关系， 组装成一个个包含多个模块的chunk 再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；
 - 输出完成： 确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。